import { objectType, arg, intArg, stringArg, nonNull, idArg, interfaceType, inputObjectType, enumType, scalarType } from '@nexus/schema';

const AggregateAnswer = objectType({
  name: "AggregateAnswer",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateConfiguration = objectType({
  name: "AggregateConfiguration",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateFlag = objectType({
  name: "AggregateFlag",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateHistoryAction = objectType({
  name: "AggregateHistoryAction",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateQuestion = objectType({
  name: "AggregateQuestion",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateSource = objectType({
  name: "AggregateSource",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateTag = objectType({
  name: "AggregateTag",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateTagCategory = objectType({
  name: "AggregateTagCategory",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateTagLabel = objectType({
  name: "AggregateTagLabel",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateTranslation = objectType({
  name: "AggregateTranslation",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateUser = objectType({
  name: "AggregateUser",
  definition(t) {
    t.nonNull.int("count")
  }
})
const AggregateZNode = objectType({
  name: "AggregateZNode",
  definition(t) {
    t.nonNull.int("count")
  }
})
const Answer = objectType({
  name: "Answer",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.field("translation", { type: Translation })
    t.string("certified")
    t.list.nonNull.field("sources", {
      type: Source,
      args: {
        where: arg({ type: SourceWhereInput }),
        orderBy: arg({ type: SourceOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.field("user", { type: User })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const AnswerConnection = objectType({
  name: "AnswerConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: AnswerEdge })
    t.nonNull.field("aggregate", { type: AggregateAnswer })
  }
})
const AnswerEdge = objectType({
  name: "AnswerEdge",
  definition(t) {
    t.nonNull.field("node", { type: Answer })
    t.nonNull.string("cursor")
  }
})
const AnswerPreviousValues = objectType({
  name: "AnswerPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.string("certified")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const AnswerSubscriptionPayload = objectType({
  name: "AnswerSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Answer })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: AnswerPreviousValues })
  }
})
const BatchPayload = objectType({
  name: "BatchPayload",
  definition(t) {
    t.nonNull.field("count", { type: Long })
  }
})
const Configuration = objectType({
  name: "Configuration",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.nonNull.string("title")
    t.nonNull.string("auth0Domain")
    t.nonNull.string("auth0ClientId")
    t.nonNull.list.nonNull.string("authorizedDomains")
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.list.nonNull.field("tagCategories", {
      type: TagCategory,
      args: {
        where: arg({ type: TagCategoryWhereInput }),
        orderBy: arg({ type: TagCategoryOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const ConfigurationConnection = objectType({
  name: "ConfigurationConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: ConfigurationEdge })
    t.nonNull.field("aggregate", { type: AggregateConfiguration })
  }
})
const ConfigurationEdge = objectType({
  name: "ConfigurationEdge",
  definition(t) {
    t.nonNull.field("node", { type: Configuration })
    t.nonNull.string("cursor")
  }
})
const ConfigurationPreviousValues = objectType({
  name: "ConfigurationPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.nonNull.string("title")
    t.nonNull.string("auth0Domain")
    t.nonNull.string("auth0ClientId")
    t.nonNull.list.nonNull.string("authorizedDomains")
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const ConfigurationSubscriptionPayload = objectType({
  name: "ConfigurationSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Configuration })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: ConfigurationPreviousValues })
  }
})
const Flag = objectType({
  name: "Flag",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("type")
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.field("user", { type: User })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const FlagConnection = objectType({
  name: "FlagConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: FlagEdge })
    t.nonNull.field("aggregate", { type: AggregateFlag })
  }
})
const FlagEdge = objectType({
  name: "FlagEdge",
  definition(t) {
    t.nonNull.field("node", { type: Flag })
    t.nonNull.string("cursor")
  }
})
const FlagPreviousValues = objectType({
  name: "FlagPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("type")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const FlagSubscriptionPayload = objectType({
  name: "FlagSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Flag })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: FlagPreviousValues })
  }
})
const HistoryAction = objectType({
  name: "HistoryAction",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("action")
    t.nonNull.string("model")
    t.field("meta", { type: Json })
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.field("user", { type: User })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const HistoryActionConnection = objectType({
  name: "HistoryActionConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: HistoryActionEdge })
    t.nonNull.field("aggregate", { type: AggregateHistoryAction })
  }
})
const HistoryActionEdge = objectType({
  name: "HistoryActionEdge",
  definition(t) {
    t.nonNull.field("node", { type: HistoryAction })
    t.nonNull.string("cursor")
  }
})
const HistoryActionPreviousValues = objectType({
  name: "HistoryActionPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("action")
    t.nonNull.string("model")
    t.field("meta", { type: Json })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const HistoryActionSubscriptionPayload = objectType({
  name: "HistoryActionSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: HistoryAction })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: HistoryActionPreviousValues })
  }
})
const Mutation = objectType({
  name: "Mutation",
  definition(t) {
    t.nonNull.field("createAnswer", {
      type: Answer,
      args: {
        data: arg({ type: nonNull(AnswerCreateInput) }),
      },
    })
    t.field("updateAnswer", {
      type: Answer,
      args: {
        data: arg({ type: nonNull(AnswerUpdateInput) }),
        where: arg({ type: nonNull(AnswerWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyAnswers", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(AnswerUpdateManyMutationInput) }),
        where: arg({ type: AnswerWhereInput }),
      },
    })
    t.nonNull.field("upsertAnswer", {
      type: Answer,
      args: {
        where: arg({ type: nonNull(AnswerWhereUniqueInput) }),
        create: arg({ type: nonNull(AnswerCreateInput) }),
        update: arg({ type: nonNull(AnswerUpdateInput) }),
      },
    })
    t.field("deleteAnswer", {
      type: Answer,
      args: {
        where: arg({ type: nonNull(AnswerWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyAnswers", {
      type: BatchPayload,
      args: {
        where: arg({ type: AnswerWhereInput }),
      },
    })
    t.nonNull.field("createConfiguration", {
      type: Configuration,
      args: {
        data: arg({ type: nonNull(ConfigurationCreateInput) }),
      },
    })
    t.field("updateConfiguration", {
      type: Configuration,
      args: {
        data: arg({ type: nonNull(ConfigurationUpdateInput) }),
        where: arg({ type: nonNull(ConfigurationWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyConfigurations", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(ConfigurationUpdateManyMutationInput) }),
        where: arg({ type: ConfigurationWhereInput }),
      },
    })
    t.nonNull.field("upsertConfiguration", {
      type: Configuration,
      args: {
        where: arg({ type: nonNull(ConfigurationWhereUniqueInput) }),
        create: arg({ type: nonNull(ConfigurationCreateInput) }),
        update: arg({ type: nonNull(ConfigurationUpdateInput) }),
      },
    })
    t.field("deleteConfiguration", {
      type: Configuration,
      args: {
        where: arg({ type: nonNull(ConfigurationWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyConfigurations", {
      type: BatchPayload,
      args: {
        where: arg({ type: ConfigurationWhereInput }),
      },
    })
    t.nonNull.field("createFlag", {
      type: Flag,
      args: {
        data: arg({ type: nonNull(FlagCreateInput) }),
      },
    })
    t.field("updateFlag", {
      type: Flag,
      args: {
        data: arg({ type: nonNull(FlagUpdateInput) }),
        where: arg({ type: nonNull(FlagWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyFlags", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(FlagUpdateManyMutationInput) }),
        where: arg({ type: FlagWhereInput }),
      },
    })
    t.nonNull.field("upsertFlag", {
      type: Flag,
      args: {
        where: arg({ type: nonNull(FlagWhereUniqueInput) }),
        create: arg({ type: nonNull(FlagCreateInput) }),
        update: arg({ type: nonNull(FlagUpdateInput) }),
      },
    })
    t.field("deleteFlag", {
      type: Flag,
      args: {
        where: arg({ type: nonNull(FlagWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyFlags", {
      type: BatchPayload,
      args: {
        where: arg({ type: FlagWhereInput }),
      },
    })
    t.nonNull.field("createHistoryAction", {
      type: HistoryAction,
      args: {
        data: arg({ type: nonNull(HistoryActionCreateInput) }),
      },
    })
    t.field("updateHistoryAction", {
      type: HistoryAction,
      args: {
        data: arg({ type: nonNull(HistoryActionUpdateInput) }),
        where: arg({ type: nonNull(HistoryActionWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyHistoryActions", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(HistoryActionUpdateManyMutationInput) }),
        where: arg({ type: HistoryActionWhereInput }),
      },
    })
    t.nonNull.field("upsertHistoryAction", {
      type: HistoryAction,
      args: {
        where: arg({ type: nonNull(HistoryActionWhereUniqueInput) }),
        create: arg({ type: nonNull(HistoryActionCreateInput) }),
        update: arg({ type: nonNull(HistoryActionUpdateInput) }),
      },
    })
    t.field("deleteHistoryAction", {
      type: HistoryAction,
      args: {
        where: arg({ type: nonNull(HistoryActionWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyHistoryActions", {
      type: BatchPayload,
      args: {
        where: arg({ type: HistoryActionWhereInput }),
      },
    })
    t.nonNull.field("createQuestion", {
      type: Question,
      args: {
        data: arg({ type: nonNull(QuestionCreateInput) }),
      },
    })
    t.field("updateQuestion", {
      type: Question,
      args: {
        data: arg({ type: nonNull(QuestionUpdateInput) }),
        where: arg({ type: nonNull(QuestionWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyQuestions", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(QuestionUpdateManyMutationInput) }),
        where: arg({ type: QuestionWhereInput }),
      },
    })
    t.nonNull.field("upsertQuestion", {
      type: Question,
      args: {
        where: arg({ type: nonNull(QuestionWhereUniqueInput) }),
        create: arg({ type: nonNull(QuestionCreateInput) }),
        update: arg({ type: nonNull(QuestionUpdateInput) }),
      },
    })
    t.field("deleteQuestion", {
      type: Question,
      args: {
        where: arg({ type: nonNull(QuestionWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyQuestions", {
      type: BatchPayload,
      args: {
        where: arg({ type: QuestionWhereInput }),
      },
    })
    t.nonNull.field("createSource", {
      type: Source,
      args: {
        data: arg({ type: nonNull(SourceCreateInput) }),
      },
    })
    t.field("updateSource", {
      type: Source,
      args: {
        data: arg({ type: nonNull(SourceUpdateInput) }),
        where: arg({ type: nonNull(SourceWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManySources", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(SourceUpdateManyMutationInput) }),
        where: arg({ type: SourceWhereInput }),
      },
    })
    t.nonNull.field("upsertSource", {
      type: Source,
      args: {
        where: arg({ type: nonNull(SourceWhereUniqueInput) }),
        create: arg({ type: nonNull(SourceCreateInput) }),
        update: arg({ type: nonNull(SourceUpdateInput) }),
      },
    })
    t.field("deleteSource", {
      type: Source,
      args: {
        where: arg({ type: nonNull(SourceWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManySources", {
      type: BatchPayload,
      args: {
        where: arg({ type: SourceWhereInput }),
      },
    })
    t.nonNull.field("createTag", {
      type: Tag,
      args: {
        data: arg({ type: nonNull(TagCreateInput) }),
      },
    })
    t.field("updateTag", {
      type: Tag,
      args: {
        data: arg({ type: nonNull(TagUpdateInput) }),
        where: arg({ type: nonNull(TagWhereUniqueInput) }),
      },
    })
    t.nonNull.field("upsertTag", {
      type: Tag,
      args: {
        where: arg({ type: nonNull(TagWhereUniqueInput) }),
        create: arg({ type: nonNull(TagCreateInput) }),
        update: arg({ type: nonNull(TagUpdateInput) }),
      },
    })
    t.field("deleteTag", {
      type: Tag,
      args: {
        where: arg({ type: nonNull(TagWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyTags", {
      type: BatchPayload,
      args: {
        where: arg({ type: TagWhereInput }),
      },
    })
    t.nonNull.field("createTagCategory", {
      type: TagCategory,
      args: {
        data: arg({ type: nonNull(TagCategoryCreateInput) }),
      },
    })
    t.field("updateTagCategory", {
      type: TagCategory,
      args: {
        data: arg({ type: nonNull(TagCategoryUpdateInput) }),
        where: arg({ type: nonNull(TagCategoryWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyTagCategories", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(TagCategoryUpdateManyMutationInput) }),
        where: arg({ type: TagCategoryWhereInput }),
      },
    })
    t.nonNull.field("upsertTagCategory", {
      type: TagCategory,
      args: {
        where: arg({ type: nonNull(TagCategoryWhereUniqueInput) }),
        create: arg({ type: nonNull(TagCategoryCreateInput) }),
        update: arg({ type: nonNull(TagCategoryUpdateInput) }),
      },
    })
    t.field("deleteTagCategory", {
      type: TagCategory,
      args: {
        where: arg({ type: nonNull(TagCategoryWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyTagCategories", {
      type: BatchPayload,
      args: {
        where: arg({ type: TagCategoryWhereInput }),
      },
    })
    t.nonNull.field("createTagLabel", {
      type: TagLabel,
      args: {
        data: arg({ type: nonNull(TagLabelCreateInput) }),
      },
    })
    t.field("updateTagLabel", {
      type: TagLabel,
      args: {
        data: arg({ type: nonNull(TagLabelUpdateInput) }),
        where: arg({ type: nonNull(TagLabelWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyTagLabels", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(TagLabelUpdateManyMutationInput) }),
        where: arg({ type: TagLabelWhereInput }),
      },
    })
    t.nonNull.field("upsertTagLabel", {
      type: TagLabel,
      args: {
        where: arg({ type: nonNull(TagLabelWhereUniqueInput) }),
        create: arg({ type: nonNull(TagLabelCreateInput) }),
        update: arg({ type: nonNull(TagLabelUpdateInput) }),
      },
    })
    t.field("deleteTagLabel", {
      type: TagLabel,
      args: {
        where: arg({ type: nonNull(TagLabelWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyTagLabels", {
      type: BatchPayload,
      args: {
        where: arg({ type: TagLabelWhereInput }),
      },
    })
    t.nonNull.field("createTranslation", {
      type: Translation,
      args: {
        data: arg({ type: nonNull(TranslationCreateInput) }),
      },
    })
    t.field("updateTranslation", {
      type: Translation,
      args: {
        data: arg({ type: nonNull(TranslationUpdateInput) }),
        where: arg({ type: nonNull(TranslationWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyTranslations", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(TranslationUpdateManyMutationInput) }),
        where: arg({ type: TranslationWhereInput }),
      },
    })
    t.nonNull.field("upsertTranslation", {
      type: Translation,
      args: {
        where: arg({ type: nonNull(TranslationWhereUniqueInput) }),
        create: arg({ type: nonNull(TranslationCreateInput) }),
        update: arg({ type: nonNull(TranslationUpdateInput) }),
      },
    })
    t.field("deleteTranslation", {
      type: Translation,
      args: {
        where: arg({ type: nonNull(TranslationWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyTranslations", {
      type: BatchPayload,
      args: {
        where: arg({ type: TranslationWhereInput }),
      },
    })
    t.nonNull.field("createUser", {
      type: User,
      args: {
        data: arg({ type: nonNull(UserCreateInput) }),
      },
    })
    t.field("updateUser", {
      type: User,
      args: {
        data: arg({ type: nonNull(UserUpdateInput) }),
        where: arg({ type: nonNull(UserWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyUsers", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(UserUpdateManyMutationInput) }),
        where: arg({ type: UserWhereInput }),
      },
    })
    t.nonNull.field("upsertUser", {
      type: User,
      args: {
        where: arg({ type: nonNull(UserWhereUniqueInput) }),
        create: arg({ type: nonNull(UserCreateInput) }),
        update: arg({ type: nonNull(UserUpdateInput) }),
      },
    })
    t.field("deleteUser", {
      type: User,
      args: {
        where: arg({ type: nonNull(UserWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyUsers", {
      type: BatchPayload,
      args: {
        where: arg({ type: UserWhereInput }),
      },
    })
    t.nonNull.field("createZNode", {
      type: ZNode,
      args: {
        data: arg({ type: nonNull(ZNodeCreateInput) }),
      },
    })
    t.field("updateZNode", {
      type: ZNode,
      args: {
        data: arg({ type: nonNull(ZNodeUpdateInput) }),
        where: arg({ type: nonNull(ZNodeWhereUniqueInput) }),
      },
    })
    t.nonNull.field("updateManyZNodes", {
      type: BatchPayload,
      args: {
        data: arg({ type: nonNull(ZNodeUpdateManyMutationInput) }),
        where: arg({ type: ZNodeWhereInput }),
      },
    })
    t.nonNull.field("upsertZNode", {
      type: ZNode,
      args: {
        where: arg({ type: nonNull(ZNodeWhereUniqueInput) }),
        create: arg({ type: nonNull(ZNodeCreateInput) }),
        update: arg({ type: nonNull(ZNodeUpdateInput) }),
      },
    })
    t.field("deleteZNode", {
      type: ZNode,
      args: {
        where: arg({ type: nonNull(ZNodeWhereUniqueInput) }),
      },
    })
    t.nonNull.field("deleteManyZNodes", {
      type: BatchPayload,
      args: {
        where: arg({ type: ZNodeWhereInput }),
      },
    })
  }
})
const PageInfo = objectType({
  name: "PageInfo",
  definition(t) {
    t.nonNull.boolean("hasNextPage")
    t.nonNull.boolean("hasPreviousPage")
    t.string("startCursor")
    t.string("endCursor")
  }
})
const Query = objectType({
  name: "Query",
  definition(t) {
    t.field("answer", {
      type: Answer,
      args: {
        where: arg({ type: nonNull(AnswerWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("answers", {
      type: Answer,
      args: {
        where: arg({ type: AnswerWhereInput }),
        orderBy: arg({ type: AnswerOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("answersConnection", {
      type: AnswerConnection,
      args: {
        where: arg({ type: AnswerWhereInput }),
        orderBy: arg({ type: AnswerOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("configuration", {
      type: Configuration,
      args: {
        where: arg({ type: nonNull(ConfigurationWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("configurations", {
      type: Configuration,
      args: {
        where: arg({ type: ConfigurationWhereInput }),
        orderBy: arg({ type: ConfigurationOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("configurationsConnection", {
      type: ConfigurationConnection,
      args: {
        where: arg({ type: ConfigurationWhereInput }),
        orderBy: arg({ type: ConfigurationOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("flag", {
      type: Flag,
      args: {
        where: arg({ type: nonNull(FlagWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("flags", {
      type: Flag,
      args: {
        where: arg({ type: FlagWhereInput }),
        orderBy: arg({ type: FlagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("flagsConnection", {
      type: FlagConnection,
      args: {
        where: arg({ type: FlagWhereInput }),
        orderBy: arg({ type: FlagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("historyAction", {
      type: HistoryAction,
      args: {
        where: arg({ type: nonNull(HistoryActionWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("historyActions", {
      type: HistoryAction,
      args: {
        where: arg({ type: HistoryActionWhereInput }),
        orderBy: arg({ type: HistoryActionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("historyActionsConnection", {
      type: HistoryActionConnection,
      args: {
        where: arg({ type: HistoryActionWhereInput }),
        orderBy: arg({ type: HistoryActionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("question", {
      type: Question,
      args: {
        where: arg({ type: nonNull(QuestionWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("questions", {
      type: Question,
      args: {
        where: arg({ type: QuestionWhereInput }),
        orderBy: arg({ type: QuestionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("questionsConnection", {
      type: QuestionConnection,
      args: {
        where: arg({ type: QuestionWhereInput }),
        orderBy: arg({ type: QuestionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("source", {
      type: Source,
      args: {
        where: arg({ type: nonNull(SourceWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("sources", {
      type: Source,
      args: {
        where: arg({ type: SourceWhereInput }),
        orderBy: arg({ type: SourceOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("sourcesConnection", {
      type: SourceConnection,
      args: {
        where: arg({ type: SourceWhereInput }),
        orderBy: arg({ type: SourceOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("tag", {
      type: Tag,
      args: {
        where: arg({ type: nonNull(TagWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("tags", {
      type: Tag,
      args: {
        where: arg({ type: TagWhereInput }),
        orderBy: arg({ type: TagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("tagsConnection", {
      type: TagConnection,
      args: {
        where: arg({ type: TagWhereInput }),
        orderBy: arg({ type: TagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("tagCategory", {
      type: TagCategory,
      args: {
        where: arg({ type: nonNull(TagCategoryWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("tagCategories", {
      type: TagCategory,
      args: {
        where: arg({ type: TagCategoryWhereInput }),
        orderBy: arg({ type: TagCategoryOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("tagCategoriesConnection", {
      type: TagCategoryConnection,
      args: {
        where: arg({ type: TagCategoryWhereInput }),
        orderBy: arg({ type: TagCategoryOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("tagLabel", {
      type: TagLabel,
      args: {
        where: arg({ type: nonNull(TagLabelWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("tagLabels", {
      type: TagLabel,
      args: {
        where: arg({ type: TagLabelWhereInput }),
        orderBy: arg({ type: TagLabelOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("tagLabelsConnection", {
      type: TagLabelConnection,
      args: {
        where: arg({ type: TagLabelWhereInput }),
        orderBy: arg({ type: TagLabelOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("translation", {
      type: Translation,
      args: {
        where: arg({ type: nonNull(TranslationWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("translations", {
      type: Translation,
      args: {
        where: arg({ type: TranslationWhereInput }),
        orderBy: arg({ type: TranslationOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("translationsConnection", {
      type: TranslationConnection,
      args: {
        where: arg({ type: TranslationWhereInput }),
        orderBy: arg({ type: TranslationOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("user", {
      type: User,
      args: {
        where: arg({ type: nonNull(UserWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("users", {
      type: User,
      args: {
        where: arg({ type: UserWhereInput }),
        orderBy: arg({ type: UserOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("usersConnection", {
      type: UserConnection,
      args: {
        where: arg({ type: UserWhereInput }),
        orderBy: arg({ type: UserOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("zNode", {
      type: ZNode,
      args: {
        where: arg({ type: nonNull(ZNodeWhereUniqueInput) }),
      },
    })
    t.nonNull.list.field("zNodes", {
      type: ZNode,
      args: {
        where: arg({ type: ZNodeWhereInput }),
        orderBy: arg({ type: ZNodeOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("zNodesConnection", {
      type: ZNodeConnection,
      args: {
        where: arg({ type: ZNodeWhereInput }),
        orderBy: arg({ type: ZNodeOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("node", {
      type: Node,
      args: {
        id: nonNull(idArg()),
      },
    })
  }
})
const Question = objectType({
  name: "Question",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("title")
    t.nonNull.string("language")
    t.field("translation", { type: Translation })
    t.nonNull.string("slug")
    t.int("views")
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.field("user", { type: User })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const QuestionConnection = objectType({
  name: "QuestionConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: QuestionEdge })
    t.nonNull.field("aggregate", { type: AggregateQuestion })
  }
})
const QuestionEdge = objectType({
  name: "QuestionEdge",
  definition(t) {
    t.nonNull.field("node", { type: Question })
    t.nonNull.string("cursor")
  }
})
const QuestionPreviousValues = objectType({
  name: "QuestionPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("title")
    t.nonNull.string("language")
    t.nonNull.string("slug")
    t.int("views")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const QuestionSubscriptionPayload = objectType({
  name: "QuestionSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Question })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: QuestionPreviousValues })
  }
})
const Source = objectType({
  name: "Source",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("label")
    t.nonNull.string("url")
    t.nonNull.field("answer", { type: Answer })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const SourceConnection = objectType({
  name: "SourceConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: SourceEdge })
    t.nonNull.field("aggregate", { type: AggregateSource })
  }
})
const SourceEdge = objectType({
  name: "SourceEdge",
  definition(t) {
    t.nonNull.field("node", { type: Source })
    t.nonNull.string("cursor")
  }
})
const SourcePreviousValues = objectType({
  name: "SourcePreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("label")
    t.nonNull.string("url")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const SourceSubscriptionPayload = objectType({
  name: "SourceSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Source })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: SourcePreviousValues })
  }
})
const Subscription = objectType({
  name: "Subscription",
  definition(t) {
    t.field("answer", {
      type: AnswerSubscriptionPayload,
      args: {
        where: arg({ type: AnswerSubscriptionWhereInput }),
      },
    })
    t.field("configuration", {
      type: ConfigurationSubscriptionPayload,
      args: {
        where: arg({ type: ConfigurationSubscriptionWhereInput }),
      },
    })
    t.field("flag", {
      type: FlagSubscriptionPayload,
      args: {
        where: arg({ type: FlagSubscriptionWhereInput }),
      },
    })
    t.field("historyAction", {
      type: HistoryActionSubscriptionPayload,
      args: {
        where: arg({ type: HistoryActionSubscriptionWhereInput }),
      },
    })
    t.field("question", {
      type: QuestionSubscriptionPayload,
      args: {
        where: arg({ type: QuestionSubscriptionWhereInput }),
      },
    })
    t.field("source", {
      type: SourceSubscriptionPayload,
      args: {
        where: arg({ type: SourceSubscriptionWhereInput }),
      },
    })
    t.field("tag", {
      type: TagSubscriptionPayload,
      args: {
        where: arg({ type: TagSubscriptionWhereInput }),
      },
    })
    t.field("tagCategory", {
      type: TagCategorySubscriptionPayload,
      args: {
        where: arg({ type: TagCategorySubscriptionWhereInput }),
      },
    })
    t.field("tagLabel", {
      type: TagLabelSubscriptionPayload,
      args: {
        where: arg({ type: TagLabelSubscriptionWhereInput }),
      },
    })
    t.field("translation", {
      type: TranslationSubscriptionPayload,
      args: {
        where: arg({ type: TranslationSubscriptionWhereInput }),
      },
    })
    t.field("user", {
      type: UserSubscriptionPayload,
      args: {
        where: arg({ type: UserSubscriptionWhereInput }),
      },
    })
    t.field("zNode", {
      type: ZNodeSubscriptionPayload,
      args: {
        where: arg({ type: ZNodeSubscriptionWhereInput }),
      },
    })
  }
})
const Tag = objectType({
  name: "Tag",
  definition(t) {
    t.nonNull.id("id")
    t.field("label", { type: TagLabel })
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.field("user", { type: User })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagCategory = objectType({
  name: "TagCategory",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.list.nonNull.field("labels", {
      type: TagLabel,
      args: {
        where: arg({ type: TagLabelWhereInput }),
        orderBy: arg({ type: TagLabelOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.int("order")
    t.nonNull.field("configuration", { type: Configuration })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagCategoryConnection = objectType({
  name: "TagCategoryConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: TagCategoryEdge })
    t.nonNull.field("aggregate", { type: AggregateTagCategory })
  }
})
const TagCategoryEdge = objectType({
  name: "TagCategoryEdge",
  definition(t) {
    t.nonNull.field("node", { type: TagCategory })
    t.nonNull.string("cursor")
  }
})
const TagCategoryPreviousValues = objectType({
  name: "TagCategoryPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.nonNull.int("order")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagCategorySubscriptionPayload = objectType({
  name: "TagCategorySubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: TagCategory })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: TagCategoryPreviousValues })
  }
})
const TagConnection = objectType({
  name: "TagConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: TagEdge })
    t.nonNull.field("aggregate", { type: AggregateTag })
  }
})
const TagEdge = objectType({
  name: "TagEdge",
  definition(t) {
    t.nonNull.field("node", { type: Tag })
    t.nonNull.string("cursor")
  }
})
const TagLabel = objectType({
  name: "TagLabel",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.list.nonNull.field("tags", {
      type: Tag,
      args: {
        where: arg({ type: TagWhereInput }),
        orderBy: arg({ type: TagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("specialists", {
      type: User,
      args: {
        where: arg({ type: UserWhereInput }),
        orderBy: arg({ type: UserOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.int("order")
    t.nonNull.field("category", { type: TagCategory })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagLabelConnection = objectType({
  name: "TagLabelConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: TagLabelEdge })
    t.nonNull.field("aggregate", { type: AggregateTagLabel })
  }
})
const TagLabelEdge = objectType({
  name: "TagLabelEdge",
  definition(t) {
    t.nonNull.field("node", { type: TagLabel })
    t.nonNull.string("cursor")
  }
})
const TagLabelPreviousValues = objectType({
  name: "TagLabelPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("name")
    t.nonNull.int("order")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagLabelSubscriptionPayload = objectType({
  name: "TagLabelSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: TagLabel })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: TagLabelPreviousValues })
  }
})
const TagPreviousValues = objectType({
  name: "TagPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const TagSubscriptionPayload = objectType({
  name: "TagSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Tag })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: TagPreviousValues })
  }
})
const Translation = objectType({
  name: "Translation",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("language")
    t.nonNull.string("text")
  }
})
const TranslationConnection = objectType({
  name: "TranslationConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: TranslationEdge })
    t.nonNull.field("aggregate", { type: AggregateTranslation })
  }
})
const TranslationEdge = objectType({
  name: "TranslationEdge",
  definition(t) {
    t.nonNull.field("node", { type: Translation })
    t.nonNull.string("cursor")
  }
})
const TranslationPreviousValues = objectType({
  name: "TranslationPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.nonNull.string("language")
    t.nonNull.string("text")
  }
})
const TranslationSubscriptionPayload = objectType({
  name: "TranslationSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: Translation })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: TranslationPreviousValues })
  }
})
const User = objectType({
  name: "User",
  definition(t) {
    t.nonNull.id("id")
    t.string("auth0Id")
    t.string("key")
    t.nonNull.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.list.nonNull.field("questions", {
      type: Question,
      args: {
        where: arg({ type: QuestionWhereInput }),
        orderBy: arg({ type: QuestionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("answers", {
      type: Answer,
      args: {
        where: arg({ type: AnswerWhereInput }),
        orderBy: arg({ type: AnswerOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("flags", {
      type: Flag,
      args: {
        where: arg({ type: FlagWhereInput }),
        orderBy: arg({ type: FlagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("tags", {
      type: Tag,
      args: {
        where: arg({ type: TagWhereInput }),
        orderBy: arg({ type: TagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("specialties", {
      type: TagLabel,
      args: {
        where: arg({ type: TagLabelWhereInput }),
        orderBy: arg({ type: TagLabelOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("history", {
      type: HistoryAction,
      args: {
        where: arg({ type: HistoryActionWhereInput }),
        orderBy: arg({ type: HistoryActionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const UserConnection = objectType({
  name: "UserConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: UserEdge })
    t.nonNull.field("aggregate", { type: AggregateUser })
  }
})
const UserEdge = objectType({
  name: "UserEdge",
  definition(t) {
    t.nonNull.field("node", { type: User })
    t.nonNull.string("cursor")
  }
})
const UserPreviousValues = objectType({
  name: "UserPreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.string("auth0Id")
    t.string("key")
    t.nonNull.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const UserSubscriptionPayload = objectType({
  name: "UserSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: User })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: UserPreviousValues })
  }
})
const ZNode = objectType({
  name: "ZNode",
  definition(t) {
    t.nonNull.id("id")
    t.field("question", { type: Question })
    t.field("answer", { type: Answer })
    t.list.nonNull.field("flags", {
      type: Flag,
      args: {
        where: arg({ type: FlagWhereInput }),
        orderBy: arg({ type: FlagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("tags", {
      type: Tag,
      args: {
        where: arg({ type: TagWhereInput }),
        orderBy: arg({ type: TagOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.list.nonNull.field("history", {
      type: HistoryAction,
      args: {
        where: arg({ type: HistoryActionWhereInput }),
        orderBy: arg({ type: HistoryActionOrderByInput }),
        skip: intArg(),
        after: stringArg(),
        before: stringArg(),
        first: intArg(),
        last: intArg(),
      },
    })
    t.field("highlights", { type: Json })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const ZNodeConnection = objectType({
  name: "ZNodeConnection",
  definition(t) {
    t.nonNull.field("pageInfo", { type: PageInfo })
    t.nonNull.list.field("edges", { type: ZNodeEdge })
    t.nonNull.field("aggregate", { type: AggregateZNode })
  }
})
const ZNodeEdge = objectType({
  name: "ZNodeEdge",
  definition(t) {
    t.nonNull.field("node", { type: ZNode })
    t.nonNull.string("cursor")
  }
})
const ZNodePreviousValues = objectType({
  name: "ZNodePreviousValues",
  definition(t) {
    t.nonNull.id("id")
    t.field("highlights", { type: Json })
    t.nonNull.field("createdAt", { type: DateTime })
    t.nonNull.field("updatedAt", { type: DateTime })
  }
})
const ZNodeSubscriptionPayload = objectType({
  name: "ZNodeSubscriptionPayload",
  definition(t) {
    t.nonNull.field("mutation", { type: MutationType })
    t.field("node", { type: ZNode })
    t.list.nonNull.string("updatedFields")
    t.field("previousValues", { type: ZNodePreviousValues })
  }
})

const Node = interfaceType({
  name: "Node",
  definition(t) {
    t.nonNull.id("id")
  }
});

const AnswerCreateInput = inputObjectType({
  name: "AnswerCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceCreateManyWithoutAnswerInput })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutAnswerInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutAnswersInput })
  }
});
const AnswerCreateManyWithoutUserInput = inputObjectType({
  name: "AnswerCreateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: AnswerCreateWithoutUserInput })
    t.list.nonNull.field("connect", { type: AnswerWhereUniqueInput })
  }
});
const AnswerCreateOneWithoutNodeInput = inputObjectType({
  name: "AnswerCreateOneWithoutNodeInput",
  definition(t) {
    t.field("create", { type: AnswerCreateWithoutNodeInput })
    t.field("connect", { type: AnswerWhereUniqueInput })
  }
});
const AnswerCreateOneWithoutSourcesInput = inputObjectType({
  name: "AnswerCreateOneWithoutSourcesInput",
  definition(t) {
    t.field("create", { type: AnswerCreateWithoutSourcesInput })
    t.field("connect", { type: AnswerWhereUniqueInput })
  }
});
const AnswerCreateWithoutNodeInput = inputObjectType({
  name: "AnswerCreateWithoutNodeInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceCreateManyWithoutAnswerInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutAnswersInput })
  }
});
const AnswerCreateWithoutSourcesInput = inputObjectType({
  name: "AnswerCreateWithoutSourcesInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.string("certified")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutAnswerInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutAnswersInput })
  }
});
const AnswerCreateWithoutUserInput = inputObjectType({
  name: "AnswerCreateWithoutUserInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("content")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceCreateManyWithoutAnswerInput })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutAnswerInput })
  }
});
const AnswerScalarWhereInput = inputObjectType({
  name: "AnswerScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("content")
    t.string("content_not")
    t.list.nonNull.string("content_in")
    t.list.nonNull.string("content_not_in")
    t.string("content_lt")
    t.string("content_lte")
    t.string("content_gt")
    t.string("content_gte")
    t.string("content_contains")
    t.string("content_not_contains")
    t.string("content_starts_with")
    t.string("content_not_starts_with")
    t.string("content_ends_with")
    t.string("content_not_ends_with")
    t.string("language")
    t.string("language_not")
    t.list.nonNull.string("language_in")
    t.list.nonNull.string("language_not_in")
    t.string("language_lt")
    t.string("language_lte")
    t.string("language_gt")
    t.string("language_gte")
    t.string("language_contains")
    t.string("language_not_contains")
    t.string("language_starts_with")
    t.string("language_not_starts_with")
    t.string("language_ends_with")
    t.string("language_not_ends_with")
    t.string("certified")
    t.string("certified_not")
    t.list.nonNull.string("certified_in")
    t.list.nonNull.string("certified_not_in")
    t.string("certified_lt")
    t.string("certified_lte")
    t.string("certified_gt")
    t.string("certified_gte")
    t.string("certified_contains")
    t.string("certified_not_contains")
    t.string("certified_starts_with")
    t.string("certified_not_starts_with")
    t.string("certified_ends_with")
    t.string("certified_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: AnswerScalarWhereInput })
    t.list.nonNull.field("OR", { type: AnswerScalarWhereInput })
    t.list.nonNull.field("NOT", { type: AnswerScalarWhereInput })
  }
});
const AnswerSubscriptionWhereInput = inputObjectType({
  name: "AnswerSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: AnswerWhereInput })
    t.list.nonNull.field("AND", { type: AnswerSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: AnswerSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: AnswerSubscriptionWhereInput })
  }
});
const AnswerUpdateInput = inputObjectType({
  name: "AnswerUpdateInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceUpdateManyWithoutAnswerInput })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutAnswerInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutAnswersInput })
  }
});
const AnswerUpdateManyDataInput = inputObjectType({
  name: "AnswerUpdateManyDataInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.string("certified")
  }
});
const AnswerUpdateManyMutationInput = inputObjectType({
  name: "AnswerUpdateManyMutationInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.string("certified")
  }
});
const AnswerUpdateManyWithWhereNestedInput = inputObjectType({
  name: "AnswerUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: AnswerScalarWhereInput })
    t.nonNull.field("data", { type: AnswerUpdateManyDataInput })
  }
});
const AnswerUpdateManyWithoutUserInput = inputObjectType({
  name: "AnswerUpdateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: AnswerCreateWithoutUserInput })
    t.list.nonNull.field("delete", { type: AnswerWhereUniqueInput })
    t.list.nonNull.field("connect", { type: AnswerWhereUniqueInput })
    t.list.nonNull.field("set", { type: AnswerWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: AnswerWhereUniqueInput })
    t.list.nonNull.field("update", { type: AnswerUpdateWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("upsert", { type: AnswerUpsertWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("deleteMany", { type: AnswerScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: AnswerUpdateManyWithWhereNestedInput })
  }
});
const AnswerUpdateOneRequiredWithoutSourcesInput = inputObjectType({
  name: "AnswerUpdateOneRequiredWithoutSourcesInput",
  definition(t) {
    t.field("create", { type: AnswerCreateWithoutSourcesInput })
    t.field("update", { type: AnswerUpdateWithoutSourcesDataInput })
    t.field("upsert", { type: AnswerUpsertWithoutSourcesInput })
    t.field("connect", { type: AnswerWhereUniqueInput })
  }
});
const AnswerUpdateOneWithoutNodeInput = inputObjectType({
  name: "AnswerUpdateOneWithoutNodeInput",
  definition(t) {
    t.field("create", { type: AnswerCreateWithoutNodeInput })
    t.field("update", { type: AnswerUpdateWithoutNodeDataInput })
    t.field("upsert", { type: AnswerUpsertWithoutNodeInput })
    t.boolean("delete")
    t.boolean("disconnect")
    t.field("connect", { type: AnswerWhereUniqueInput })
  }
});
const AnswerUpdateWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "AnswerUpdateWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: AnswerWhereUniqueInput })
    t.nonNull.field("data", { type: AnswerUpdateWithoutUserDataInput })
  }
});
const AnswerUpdateWithoutNodeDataInput = inputObjectType({
  name: "AnswerUpdateWithoutNodeDataInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceUpdateManyWithoutAnswerInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutAnswersInput })
  }
});
const AnswerUpdateWithoutSourcesDataInput = inputObjectType({
  name: "AnswerUpdateWithoutSourcesDataInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("certified")
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutAnswerInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutAnswersInput })
  }
});
const AnswerUpdateWithoutUserDataInput = inputObjectType({
  name: "AnswerUpdateWithoutUserDataInput",
  definition(t) {
    t.string("content")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("certified")
    t.field("sources", { type: SourceUpdateManyWithoutAnswerInput })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutAnswerInput })
  }
});
const AnswerUpsertWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "AnswerUpsertWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: AnswerWhereUniqueInput })
    t.nonNull.field("update", { type: AnswerUpdateWithoutUserDataInput })
    t.nonNull.field("create", { type: AnswerCreateWithoutUserInput })
  }
});
const AnswerUpsertWithoutNodeInput = inputObjectType({
  name: "AnswerUpsertWithoutNodeInput",
  definition(t) {
    t.nonNull.field("update", { type: AnswerUpdateWithoutNodeDataInput })
    t.nonNull.field("create", { type: AnswerCreateWithoutNodeInput })
  }
});
const AnswerUpsertWithoutSourcesInput = inputObjectType({
  name: "AnswerUpsertWithoutSourcesInput",
  definition(t) {
    t.nonNull.field("update", { type: AnswerUpdateWithoutSourcesDataInput })
    t.nonNull.field("create", { type: AnswerCreateWithoutSourcesInput })
  }
});
const AnswerWhereInput = inputObjectType({
  name: "AnswerWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("content")
    t.string("content_not")
    t.list.nonNull.string("content_in")
    t.list.nonNull.string("content_not_in")
    t.string("content_lt")
    t.string("content_lte")
    t.string("content_gt")
    t.string("content_gte")
    t.string("content_contains")
    t.string("content_not_contains")
    t.string("content_starts_with")
    t.string("content_not_starts_with")
    t.string("content_ends_with")
    t.string("content_not_ends_with")
    t.string("language")
    t.string("language_not")
    t.list.nonNull.string("language_in")
    t.list.nonNull.string("language_not_in")
    t.string("language_lt")
    t.string("language_lte")
    t.string("language_gt")
    t.string("language_gte")
    t.string("language_contains")
    t.string("language_not_contains")
    t.string("language_starts_with")
    t.string("language_not_starts_with")
    t.string("language_ends_with")
    t.string("language_not_ends_with")
    t.field("translation", { type: TranslationWhereInput })
    t.string("certified")
    t.string("certified_not")
    t.list.nonNull.string("certified_in")
    t.list.nonNull.string("certified_not_in")
    t.string("certified_lt")
    t.string("certified_lte")
    t.string("certified_gt")
    t.string("certified_gte")
    t.string("certified_contains")
    t.string("certified_not_contains")
    t.string("certified_starts_with")
    t.string("certified_not_starts_with")
    t.string("certified_ends_with")
    t.string("certified_not_ends_with")
    t.field("sources_every", { type: SourceWhereInput })
    t.field("sources_some", { type: SourceWhereInput })
    t.field("sources_none", { type: SourceWhereInput })
    t.field("node", { type: ZNodeWhereInput })
    t.field("user", { type: UserWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: AnswerWhereInput })
    t.list.nonNull.field("OR", { type: AnswerWhereInput })
    t.list.nonNull.field("NOT", { type: AnswerWhereInput })
  }
});
const AnswerWhereUniqueInput = inputObjectType({
  name: "AnswerWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const ConfigurationCreateInput = inputObjectType({
  name: "ConfigurationCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.string("title")
    t.nonNull.string("auth0Domain")
    t.nonNull.string("auth0ClientId")
    t.field("authorizedDomains", { type: ConfigurationCreateauthorizedDomainsInput })
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.field("tagCategories", { type: TagCategoryCreateManyWithoutConfigurationInput })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
  }
});
const ConfigurationCreateOneWithoutTagCategoriesInput = inputObjectType({
  name: "ConfigurationCreateOneWithoutTagCategoriesInput",
  definition(t) {
    t.field("create", { type: ConfigurationCreateWithoutTagCategoriesInput })
    t.field("connect", { type: ConfigurationWhereUniqueInput })
  }
});
const ConfigurationCreateWithoutTagCategoriesInput = inputObjectType({
  name: "ConfigurationCreateWithoutTagCategoriesInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.string("title")
    t.nonNull.string("auth0Domain")
    t.nonNull.string("auth0ClientId")
    t.field("authorizedDomains", { type: ConfigurationCreateauthorizedDomainsInput })
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
  }
});
const ConfigurationCreateauthorizedDomainsInput = inputObjectType({
  name: "ConfigurationCreateauthorizedDomainsInput",
  definition(t) {
    t.list.nonNull.string("set")
  }
});
const ConfigurationSubscriptionWhereInput = inputObjectType({
  name: "ConfigurationSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: ConfigurationWhereInput })
    t.list.nonNull.field("AND", { type: ConfigurationSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: ConfigurationSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: ConfigurationSubscriptionWhereInput })
  }
});
const ConfigurationUpdateInput = inputObjectType({
  name: "ConfigurationUpdateInput",
  definition(t) {
    t.string("name")
    t.string("title")
    t.string("auth0Domain")
    t.string("auth0ClientId")
    t.field("authorizedDomains", { type: ConfigurationUpdateauthorizedDomainsInput })
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.field("tagCategories", { type: TagCategoryUpdateManyWithoutConfigurationInput })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
  }
});
const ConfigurationUpdateManyMutationInput = inputObjectType({
  name: "ConfigurationUpdateManyMutationInput",
  definition(t) {
    t.string("name")
    t.string("title")
    t.string("auth0Domain")
    t.string("auth0ClientId")
    t.field("authorizedDomains", { type: ConfigurationUpdateauthorizedDomainsInput })
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
  }
});
const ConfigurationUpdateOneRequiredWithoutTagCategoriesInput = inputObjectType({
  name: "ConfigurationUpdateOneRequiredWithoutTagCategoriesInput",
  definition(t) {
    t.field("create", { type: ConfigurationCreateWithoutTagCategoriesInput })
    t.field("update", { type: ConfigurationUpdateWithoutTagCategoriesDataInput })
    t.field("upsert", { type: ConfigurationUpsertWithoutTagCategoriesInput })
    t.field("connect", { type: ConfigurationWhereUniqueInput })
  }
});
const ConfigurationUpdateWithoutTagCategoriesDataInput = inputObjectType({
  name: "ConfigurationUpdateWithoutTagCategoriesDataInput",
  definition(t) {
    t.string("name")
    t.string("title")
    t.string("auth0Domain")
    t.string("auth0ClientId")
    t.field("authorizedDomains", { type: ConfigurationUpdateauthorizedDomainsInput })
    t.string("algoliaAppId")
    t.string("algoliaApiKey")
    t.field("algoliaSynonyms", { type: Json })
    t.string("mailgunDomain")
    t.string("mailgunApiKey")
    t.string("slackChannelHook")
    t.string("slackCommandKey")
    t.field("tags", { type: Json })
    t.boolean("workplaceSharing")
    t.field("bugReporting", { type: BugReporting })
  }
});
const ConfigurationUpdateauthorizedDomainsInput = inputObjectType({
  name: "ConfigurationUpdateauthorizedDomainsInput",
  definition(t) {
    t.list.nonNull.string("set")
  }
});
const ConfigurationUpsertWithoutTagCategoriesInput = inputObjectType({
  name: "ConfigurationUpsertWithoutTagCategoriesInput",
  definition(t) {
    t.nonNull.field("update", { type: ConfigurationUpdateWithoutTagCategoriesDataInput })
    t.nonNull.field("create", { type: ConfigurationCreateWithoutTagCategoriesInput })
  }
});
const ConfigurationWhereInput = inputObjectType({
  name: "ConfigurationWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.string("title")
    t.string("title_not")
    t.list.nonNull.string("title_in")
    t.list.nonNull.string("title_not_in")
    t.string("title_lt")
    t.string("title_lte")
    t.string("title_gt")
    t.string("title_gte")
    t.string("title_contains")
    t.string("title_not_contains")
    t.string("title_starts_with")
    t.string("title_not_starts_with")
    t.string("title_ends_with")
    t.string("title_not_ends_with")
    t.string("auth0Domain")
    t.string("auth0Domain_not")
    t.list.nonNull.string("auth0Domain_in")
    t.list.nonNull.string("auth0Domain_not_in")
    t.string("auth0Domain_lt")
    t.string("auth0Domain_lte")
    t.string("auth0Domain_gt")
    t.string("auth0Domain_gte")
    t.string("auth0Domain_contains")
    t.string("auth0Domain_not_contains")
    t.string("auth0Domain_starts_with")
    t.string("auth0Domain_not_starts_with")
    t.string("auth0Domain_ends_with")
    t.string("auth0Domain_not_ends_with")
    t.string("auth0ClientId")
    t.string("auth0ClientId_not")
    t.list.nonNull.string("auth0ClientId_in")
    t.list.nonNull.string("auth0ClientId_not_in")
    t.string("auth0ClientId_lt")
    t.string("auth0ClientId_lte")
    t.string("auth0ClientId_gt")
    t.string("auth0ClientId_gte")
    t.string("auth0ClientId_contains")
    t.string("auth0ClientId_not_contains")
    t.string("auth0ClientId_starts_with")
    t.string("auth0ClientId_not_starts_with")
    t.string("auth0ClientId_ends_with")
    t.string("auth0ClientId_not_ends_with")
    t.string("algoliaAppId")
    t.string("algoliaAppId_not")
    t.list.nonNull.string("algoliaAppId_in")
    t.list.nonNull.string("algoliaAppId_not_in")
    t.string("algoliaAppId_lt")
    t.string("algoliaAppId_lte")
    t.string("algoliaAppId_gt")
    t.string("algoliaAppId_gte")
    t.string("algoliaAppId_contains")
    t.string("algoliaAppId_not_contains")
    t.string("algoliaAppId_starts_with")
    t.string("algoliaAppId_not_starts_with")
    t.string("algoliaAppId_ends_with")
    t.string("algoliaAppId_not_ends_with")
    t.string("algoliaApiKey")
    t.string("algoliaApiKey_not")
    t.list.nonNull.string("algoliaApiKey_in")
    t.list.nonNull.string("algoliaApiKey_not_in")
    t.string("algoliaApiKey_lt")
    t.string("algoliaApiKey_lte")
    t.string("algoliaApiKey_gt")
    t.string("algoliaApiKey_gte")
    t.string("algoliaApiKey_contains")
    t.string("algoliaApiKey_not_contains")
    t.string("algoliaApiKey_starts_with")
    t.string("algoliaApiKey_not_starts_with")
    t.string("algoliaApiKey_ends_with")
    t.string("algoliaApiKey_not_ends_with")
    t.string("mailgunDomain")
    t.string("mailgunDomain_not")
    t.list.nonNull.string("mailgunDomain_in")
    t.list.nonNull.string("mailgunDomain_not_in")
    t.string("mailgunDomain_lt")
    t.string("mailgunDomain_lte")
    t.string("mailgunDomain_gt")
    t.string("mailgunDomain_gte")
    t.string("mailgunDomain_contains")
    t.string("mailgunDomain_not_contains")
    t.string("mailgunDomain_starts_with")
    t.string("mailgunDomain_not_starts_with")
    t.string("mailgunDomain_ends_with")
    t.string("mailgunDomain_not_ends_with")
    t.string("mailgunApiKey")
    t.string("mailgunApiKey_not")
    t.list.nonNull.string("mailgunApiKey_in")
    t.list.nonNull.string("mailgunApiKey_not_in")
    t.string("mailgunApiKey_lt")
    t.string("mailgunApiKey_lte")
    t.string("mailgunApiKey_gt")
    t.string("mailgunApiKey_gte")
    t.string("mailgunApiKey_contains")
    t.string("mailgunApiKey_not_contains")
    t.string("mailgunApiKey_starts_with")
    t.string("mailgunApiKey_not_starts_with")
    t.string("mailgunApiKey_ends_with")
    t.string("mailgunApiKey_not_ends_with")
    t.string("slackChannelHook")
    t.string("slackChannelHook_not")
    t.list.nonNull.string("slackChannelHook_in")
    t.list.nonNull.string("slackChannelHook_not_in")
    t.string("slackChannelHook_lt")
    t.string("slackChannelHook_lte")
    t.string("slackChannelHook_gt")
    t.string("slackChannelHook_gte")
    t.string("slackChannelHook_contains")
    t.string("slackChannelHook_not_contains")
    t.string("slackChannelHook_starts_with")
    t.string("slackChannelHook_not_starts_with")
    t.string("slackChannelHook_ends_with")
    t.string("slackChannelHook_not_ends_with")
    t.string("slackCommandKey")
    t.string("slackCommandKey_not")
    t.list.nonNull.string("slackCommandKey_in")
    t.list.nonNull.string("slackCommandKey_not_in")
    t.string("slackCommandKey_lt")
    t.string("slackCommandKey_lte")
    t.string("slackCommandKey_gt")
    t.string("slackCommandKey_gte")
    t.string("slackCommandKey_contains")
    t.string("slackCommandKey_not_contains")
    t.string("slackCommandKey_starts_with")
    t.string("slackCommandKey_not_starts_with")
    t.string("slackCommandKey_ends_with")
    t.string("slackCommandKey_not_ends_with")
    t.field("tagCategories_every", { type: TagCategoryWhereInput })
    t.field("tagCategories_some", { type: TagCategoryWhereInput })
    t.field("tagCategories_none", { type: TagCategoryWhereInput })
    t.boolean("workplaceSharing")
    t.boolean("workplaceSharing_not")
    t.field("bugReporting", { type: BugReporting })
    t.field("bugReporting_not", { type: BugReporting })
    t.list.nonNull.field("bugReporting_in", { type: BugReporting })
    t.list.nonNull.field("bugReporting_not_in", { type: BugReporting })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: ConfigurationWhereInput })
    t.list.nonNull.field("OR", { type: ConfigurationWhereInput })
    t.list.nonNull.field("NOT", { type: ConfigurationWhereInput })
  }
});
const ConfigurationWhereUniqueInput = inputObjectType({
  name: "ConfigurationWhereUniqueInput",
  definition(t) {
    t.id("id")
    t.string("name")
  }
});
const FlagCreateInput = inputObjectType({
  name: "FlagCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("type")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutFlagsInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutFlagsInput })
  }
});
const FlagCreateManyWithoutNodeInput = inputObjectType({
  name: "FlagCreateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: FlagCreateWithoutNodeInput })
    t.list.nonNull.field("connect", { type: FlagWhereUniqueInput })
  }
});
const FlagCreateManyWithoutUserInput = inputObjectType({
  name: "FlagCreateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: FlagCreateWithoutUserInput })
    t.list.nonNull.field("connect", { type: FlagWhereUniqueInput })
  }
});
const FlagCreateWithoutNodeInput = inputObjectType({
  name: "FlagCreateWithoutNodeInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("type")
    t.nonNull.field("user", { type: UserCreateOneWithoutFlagsInput })
  }
});
const FlagCreateWithoutUserInput = inputObjectType({
  name: "FlagCreateWithoutUserInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("type")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutFlagsInput })
  }
});
const FlagScalarWhereInput = inputObjectType({
  name: "FlagScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("type")
    t.string("type_not")
    t.list.nonNull.string("type_in")
    t.list.nonNull.string("type_not_in")
    t.string("type_lt")
    t.string("type_lte")
    t.string("type_gt")
    t.string("type_gte")
    t.string("type_contains")
    t.string("type_not_contains")
    t.string("type_starts_with")
    t.string("type_not_starts_with")
    t.string("type_ends_with")
    t.string("type_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: FlagScalarWhereInput })
    t.list.nonNull.field("OR", { type: FlagScalarWhereInput })
    t.list.nonNull.field("NOT", { type: FlagScalarWhereInput })
  }
});
const FlagSubscriptionWhereInput = inputObjectType({
  name: "FlagSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: FlagWhereInput })
    t.list.nonNull.field("AND", { type: FlagSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: FlagSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: FlagSubscriptionWhereInput })
  }
});
const FlagUpdateInput = inputObjectType({
  name: "FlagUpdateInput",
  definition(t) {
    t.string("type")
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutFlagsInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutFlagsInput })
  }
});
const FlagUpdateManyDataInput = inputObjectType({
  name: "FlagUpdateManyDataInput",
  definition(t) {
    t.string("type")
  }
});
const FlagUpdateManyMutationInput = inputObjectType({
  name: "FlagUpdateManyMutationInput",
  definition(t) {
    t.string("type")
  }
});
const FlagUpdateManyWithWhereNestedInput = inputObjectType({
  name: "FlagUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: FlagScalarWhereInput })
    t.nonNull.field("data", { type: FlagUpdateManyDataInput })
  }
});
const FlagUpdateManyWithoutNodeInput = inputObjectType({
  name: "FlagUpdateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: FlagCreateWithoutNodeInput })
    t.list.nonNull.field("delete", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("connect", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("set", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("update", { type: FlagUpdateWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("upsert", { type: FlagUpsertWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("deleteMany", { type: FlagScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: FlagUpdateManyWithWhereNestedInput })
  }
});
const FlagUpdateManyWithoutUserInput = inputObjectType({
  name: "FlagUpdateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: FlagCreateWithoutUserInput })
    t.list.nonNull.field("delete", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("connect", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("set", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: FlagWhereUniqueInput })
    t.list.nonNull.field("update", { type: FlagUpdateWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("upsert", { type: FlagUpsertWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("deleteMany", { type: FlagScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: FlagUpdateManyWithWhereNestedInput })
  }
});
const FlagUpdateWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "FlagUpdateWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: FlagWhereUniqueInput })
    t.nonNull.field("data", { type: FlagUpdateWithoutNodeDataInput })
  }
});
const FlagUpdateWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "FlagUpdateWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: FlagWhereUniqueInput })
    t.nonNull.field("data", { type: FlagUpdateWithoutUserDataInput })
  }
});
const FlagUpdateWithoutNodeDataInput = inputObjectType({
  name: "FlagUpdateWithoutNodeDataInput",
  definition(t) {
    t.string("type")
    t.field("user", { type: UserUpdateOneRequiredWithoutFlagsInput })
  }
});
const FlagUpdateWithoutUserDataInput = inputObjectType({
  name: "FlagUpdateWithoutUserDataInput",
  definition(t) {
    t.string("type")
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutFlagsInput })
  }
});
const FlagUpsertWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "FlagUpsertWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: FlagWhereUniqueInput })
    t.nonNull.field("update", { type: FlagUpdateWithoutNodeDataInput })
    t.nonNull.field("create", { type: FlagCreateWithoutNodeInput })
  }
});
const FlagUpsertWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "FlagUpsertWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: FlagWhereUniqueInput })
    t.nonNull.field("update", { type: FlagUpdateWithoutUserDataInput })
    t.nonNull.field("create", { type: FlagCreateWithoutUserInput })
  }
});
const FlagWhereInput = inputObjectType({
  name: "FlagWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("type")
    t.string("type_not")
    t.list.nonNull.string("type_in")
    t.list.nonNull.string("type_not_in")
    t.string("type_lt")
    t.string("type_lte")
    t.string("type_gt")
    t.string("type_gte")
    t.string("type_contains")
    t.string("type_not_contains")
    t.string("type_starts_with")
    t.string("type_not_starts_with")
    t.string("type_ends_with")
    t.string("type_not_ends_with")
    t.field("node", { type: ZNodeWhereInput })
    t.field("user", { type: UserWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: FlagWhereInput })
    t.list.nonNull.field("OR", { type: FlagWhereInput })
    t.list.nonNull.field("NOT", { type: FlagWhereInput })
  }
});
const FlagWhereUniqueInput = inputObjectType({
  name: "FlagWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const HistoryActionCreateInput = inputObjectType({
  name: "HistoryActionCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("action")
    t.nonNull.string("model")
    t.field("meta", { type: Json })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutHistoryInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutHistoryInput })
  }
});
const HistoryActionCreateManyWithoutNodeInput = inputObjectType({
  name: "HistoryActionCreateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: HistoryActionCreateWithoutNodeInput })
    t.list.nonNull.field("connect", { type: HistoryActionWhereUniqueInput })
  }
});
const HistoryActionCreateManyWithoutUserInput = inputObjectType({
  name: "HistoryActionCreateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: HistoryActionCreateWithoutUserInput })
    t.list.nonNull.field("connect", { type: HistoryActionWhereUniqueInput })
  }
});
const HistoryActionCreateWithoutNodeInput = inputObjectType({
  name: "HistoryActionCreateWithoutNodeInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("action")
    t.nonNull.string("model")
    t.field("meta", { type: Json })
    t.nonNull.field("user", { type: UserCreateOneWithoutHistoryInput })
  }
});
const HistoryActionCreateWithoutUserInput = inputObjectType({
  name: "HistoryActionCreateWithoutUserInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("action")
    t.nonNull.string("model")
    t.field("meta", { type: Json })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutHistoryInput })
  }
});
const HistoryActionScalarWhereInput = inputObjectType({
  name: "HistoryActionScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("action")
    t.string("action_not")
    t.list.nonNull.string("action_in")
    t.list.nonNull.string("action_not_in")
    t.string("action_lt")
    t.string("action_lte")
    t.string("action_gt")
    t.string("action_gte")
    t.string("action_contains")
    t.string("action_not_contains")
    t.string("action_starts_with")
    t.string("action_not_starts_with")
    t.string("action_ends_with")
    t.string("action_not_ends_with")
    t.string("model")
    t.string("model_not")
    t.list.nonNull.string("model_in")
    t.list.nonNull.string("model_not_in")
    t.string("model_lt")
    t.string("model_lte")
    t.string("model_gt")
    t.string("model_gte")
    t.string("model_contains")
    t.string("model_not_contains")
    t.string("model_starts_with")
    t.string("model_not_starts_with")
    t.string("model_ends_with")
    t.string("model_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: HistoryActionScalarWhereInput })
    t.list.nonNull.field("OR", { type: HistoryActionScalarWhereInput })
    t.list.nonNull.field("NOT", { type: HistoryActionScalarWhereInput })
  }
});
const HistoryActionSubscriptionWhereInput = inputObjectType({
  name: "HistoryActionSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: HistoryActionWhereInput })
    t.list.nonNull.field("AND", { type: HistoryActionSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: HistoryActionSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: HistoryActionSubscriptionWhereInput })
  }
});
const HistoryActionUpdateInput = inputObjectType({
  name: "HistoryActionUpdateInput",
  definition(t) {
    t.string("action")
    t.string("model")
    t.field("meta", { type: Json })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutHistoryInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutHistoryInput })
  }
});
const HistoryActionUpdateManyDataInput = inputObjectType({
  name: "HistoryActionUpdateManyDataInput",
  definition(t) {
    t.string("action")
    t.string("model")
    t.field("meta", { type: Json })
  }
});
const HistoryActionUpdateManyMutationInput = inputObjectType({
  name: "HistoryActionUpdateManyMutationInput",
  definition(t) {
    t.string("action")
    t.string("model")
    t.field("meta", { type: Json })
  }
});
const HistoryActionUpdateManyWithWhereNestedInput = inputObjectType({
  name: "HistoryActionUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: HistoryActionScalarWhereInput })
    t.nonNull.field("data", { type: HistoryActionUpdateManyDataInput })
  }
});
const HistoryActionUpdateManyWithoutNodeInput = inputObjectType({
  name: "HistoryActionUpdateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: HistoryActionCreateWithoutNodeInput })
    t.list.nonNull.field("delete", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("connect", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("set", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("update", { type: HistoryActionUpdateWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("upsert", { type: HistoryActionUpsertWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("deleteMany", { type: HistoryActionScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: HistoryActionUpdateManyWithWhereNestedInput })
  }
});
const HistoryActionUpdateManyWithoutUserInput = inputObjectType({
  name: "HistoryActionUpdateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: HistoryActionCreateWithoutUserInput })
    t.list.nonNull.field("delete", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("connect", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("set", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: HistoryActionWhereUniqueInput })
    t.list.nonNull.field("update", { type: HistoryActionUpdateWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("upsert", { type: HistoryActionUpsertWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("deleteMany", { type: HistoryActionScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: HistoryActionUpdateManyWithWhereNestedInput })
  }
});
const HistoryActionUpdateWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "HistoryActionUpdateWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: HistoryActionWhereUniqueInput })
    t.nonNull.field("data", { type: HistoryActionUpdateWithoutNodeDataInput })
  }
});
const HistoryActionUpdateWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "HistoryActionUpdateWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: HistoryActionWhereUniqueInput })
    t.nonNull.field("data", { type: HistoryActionUpdateWithoutUserDataInput })
  }
});
const HistoryActionUpdateWithoutNodeDataInput = inputObjectType({
  name: "HistoryActionUpdateWithoutNodeDataInput",
  definition(t) {
    t.string("action")
    t.string("model")
    t.field("meta", { type: Json })
    t.field("user", { type: UserUpdateOneRequiredWithoutHistoryInput })
  }
});
const HistoryActionUpdateWithoutUserDataInput = inputObjectType({
  name: "HistoryActionUpdateWithoutUserDataInput",
  definition(t) {
    t.string("action")
    t.string("model")
    t.field("meta", { type: Json })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutHistoryInput })
  }
});
const HistoryActionUpsertWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "HistoryActionUpsertWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: HistoryActionWhereUniqueInput })
    t.nonNull.field("update", { type: HistoryActionUpdateWithoutNodeDataInput })
    t.nonNull.field("create", { type: HistoryActionCreateWithoutNodeInput })
  }
});
const HistoryActionUpsertWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "HistoryActionUpsertWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: HistoryActionWhereUniqueInput })
    t.nonNull.field("update", { type: HistoryActionUpdateWithoutUserDataInput })
    t.nonNull.field("create", { type: HistoryActionCreateWithoutUserInput })
  }
});
const HistoryActionWhereInput = inputObjectType({
  name: "HistoryActionWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("action")
    t.string("action_not")
    t.list.nonNull.string("action_in")
    t.list.nonNull.string("action_not_in")
    t.string("action_lt")
    t.string("action_lte")
    t.string("action_gt")
    t.string("action_gte")
    t.string("action_contains")
    t.string("action_not_contains")
    t.string("action_starts_with")
    t.string("action_not_starts_with")
    t.string("action_ends_with")
    t.string("action_not_ends_with")
    t.string("model")
    t.string("model_not")
    t.list.nonNull.string("model_in")
    t.list.nonNull.string("model_not_in")
    t.string("model_lt")
    t.string("model_lte")
    t.string("model_gt")
    t.string("model_gte")
    t.string("model_contains")
    t.string("model_not_contains")
    t.string("model_starts_with")
    t.string("model_not_starts_with")
    t.string("model_ends_with")
    t.string("model_not_ends_with")
    t.field("node", { type: ZNodeWhereInput })
    t.field("user", { type: UserWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: HistoryActionWhereInput })
    t.list.nonNull.field("OR", { type: HistoryActionWhereInput })
    t.list.nonNull.field("NOT", { type: HistoryActionWhereInput })
  }
});
const HistoryActionWhereUniqueInput = inputObjectType({
  name: "HistoryActionWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const QuestionCreateInput = inputObjectType({
  name: "QuestionCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("title")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.nonNull.string("slug")
    t.int("views")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutQuestionInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutQuestionsInput })
  }
});
const QuestionCreateManyWithoutUserInput = inputObjectType({
  name: "QuestionCreateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: QuestionCreateWithoutUserInput })
    t.list.nonNull.field("connect", { type: QuestionWhereUniqueInput })
  }
});
const QuestionCreateOneWithoutNodeInput = inputObjectType({
  name: "QuestionCreateOneWithoutNodeInput",
  definition(t) {
    t.field("create", { type: QuestionCreateWithoutNodeInput })
    t.field("connect", { type: QuestionWhereUniqueInput })
  }
});
const QuestionCreateWithoutNodeInput = inputObjectType({
  name: "QuestionCreateWithoutNodeInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("title")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.nonNull.string("slug")
    t.int("views")
    t.nonNull.field("user", { type: UserCreateOneWithoutQuestionsInput })
  }
});
const QuestionCreateWithoutUserInput = inputObjectType({
  name: "QuestionCreateWithoutUserInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("title")
    t.nonNull.string("language")
    t.field("translation", { type: TranslationCreateOneInput })
    t.nonNull.string("slug")
    t.int("views")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutQuestionInput })
  }
});
const QuestionScalarWhereInput = inputObjectType({
  name: "QuestionScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("title")
    t.string("title_not")
    t.list.nonNull.string("title_in")
    t.list.nonNull.string("title_not_in")
    t.string("title_lt")
    t.string("title_lte")
    t.string("title_gt")
    t.string("title_gte")
    t.string("title_contains")
    t.string("title_not_contains")
    t.string("title_starts_with")
    t.string("title_not_starts_with")
    t.string("title_ends_with")
    t.string("title_not_ends_with")
    t.string("language")
    t.string("language_not")
    t.list.nonNull.string("language_in")
    t.list.nonNull.string("language_not_in")
    t.string("language_lt")
    t.string("language_lte")
    t.string("language_gt")
    t.string("language_gte")
    t.string("language_contains")
    t.string("language_not_contains")
    t.string("language_starts_with")
    t.string("language_not_starts_with")
    t.string("language_ends_with")
    t.string("language_not_ends_with")
    t.string("slug")
    t.string("slug_not")
    t.list.nonNull.string("slug_in")
    t.list.nonNull.string("slug_not_in")
    t.string("slug_lt")
    t.string("slug_lte")
    t.string("slug_gt")
    t.string("slug_gte")
    t.string("slug_contains")
    t.string("slug_not_contains")
    t.string("slug_starts_with")
    t.string("slug_not_starts_with")
    t.string("slug_ends_with")
    t.string("slug_not_ends_with")
    t.int("views")
    t.int("views_not")
    t.list.nonNull.int("views_in")
    t.list.nonNull.int("views_not_in")
    t.int("views_lt")
    t.int("views_lte")
    t.int("views_gt")
    t.int("views_gte")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: QuestionScalarWhereInput })
    t.list.nonNull.field("OR", { type: QuestionScalarWhereInput })
    t.list.nonNull.field("NOT", { type: QuestionScalarWhereInput })
  }
});
const QuestionSubscriptionWhereInput = inputObjectType({
  name: "QuestionSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: QuestionWhereInput })
    t.list.nonNull.field("AND", { type: QuestionSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: QuestionSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: QuestionSubscriptionWhereInput })
  }
});
const QuestionUpdateInput = inputObjectType({
  name: "QuestionUpdateInput",
  definition(t) {
    t.string("title")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("slug")
    t.int("views")
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutQuestionInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutQuestionsInput })
  }
});
const QuestionUpdateManyDataInput = inputObjectType({
  name: "QuestionUpdateManyDataInput",
  definition(t) {
    t.string("title")
    t.string("language")
    t.string("slug")
    t.int("views")
  }
});
const QuestionUpdateManyMutationInput = inputObjectType({
  name: "QuestionUpdateManyMutationInput",
  definition(t) {
    t.string("title")
    t.string("language")
    t.string("slug")
    t.int("views")
  }
});
const QuestionUpdateManyWithWhereNestedInput = inputObjectType({
  name: "QuestionUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: QuestionScalarWhereInput })
    t.nonNull.field("data", { type: QuestionUpdateManyDataInput })
  }
});
const QuestionUpdateManyWithoutUserInput = inputObjectType({
  name: "QuestionUpdateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: QuestionCreateWithoutUserInput })
    t.list.nonNull.field("delete", { type: QuestionWhereUniqueInput })
    t.list.nonNull.field("connect", { type: QuestionWhereUniqueInput })
    t.list.nonNull.field("set", { type: QuestionWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: QuestionWhereUniqueInput })
    t.list.nonNull.field("update", { type: QuestionUpdateWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("upsert", { type: QuestionUpsertWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("deleteMany", { type: QuestionScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: QuestionUpdateManyWithWhereNestedInput })
  }
});
const QuestionUpdateOneWithoutNodeInput = inputObjectType({
  name: "QuestionUpdateOneWithoutNodeInput",
  definition(t) {
    t.field("create", { type: QuestionCreateWithoutNodeInput })
    t.field("update", { type: QuestionUpdateWithoutNodeDataInput })
    t.field("upsert", { type: QuestionUpsertWithoutNodeInput })
    t.boolean("delete")
    t.boolean("disconnect")
    t.field("connect", { type: QuestionWhereUniqueInput })
  }
});
const QuestionUpdateWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "QuestionUpdateWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: QuestionWhereUniqueInput })
    t.nonNull.field("data", { type: QuestionUpdateWithoutUserDataInput })
  }
});
const QuestionUpdateWithoutNodeDataInput = inputObjectType({
  name: "QuestionUpdateWithoutNodeDataInput",
  definition(t) {
    t.string("title")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("slug")
    t.int("views")
    t.field("user", { type: UserUpdateOneRequiredWithoutQuestionsInput })
  }
});
const QuestionUpdateWithoutUserDataInput = inputObjectType({
  name: "QuestionUpdateWithoutUserDataInput",
  definition(t) {
    t.string("title")
    t.string("language")
    t.field("translation", { type: TranslationUpdateOneInput })
    t.string("slug")
    t.int("views")
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutQuestionInput })
  }
});
const QuestionUpsertWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "QuestionUpsertWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: QuestionWhereUniqueInput })
    t.nonNull.field("update", { type: QuestionUpdateWithoutUserDataInput })
    t.nonNull.field("create", { type: QuestionCreateWithoutUserInput })
  }
});
const QuestionUpsertWithoutNodeInput = inputObjectType({
  name: "QuestionUpsertWithoutNodeInput",
  definition(t) {
    t.nonNull.field("update", { type: QuestionUpdateWithoutNodeDataInput })
    t.nonNull.field("create", { type: QuestionCreateWithoutNodeInput })
  }
});
const QuestionWhereInput = inputObjectType({
  name: "QuestionWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("title")
    t.string("title_not")
    t.list.nonNull.string("title_in")
    t.list.nonNull.string("title_not_in")
    t.string("title_lt")
    t.string("title_lte")
    t.string("title_gt")
    t.string("title_gte")
    t.string("title_contains")
    t.string("title_not_contains")
    t.string("title_starts_with")
    t.string("title_not_starts_with")
    t.string("title_ends_with")
    t.string("title_not_ends_with")
    t.string("language")
    t.string("language_not")
    t.list.nonNull.string("language_in")
    t.list.nonNull.string("language_not_in")
    t.string("language_lt")
    t.string("language_lte")
    t.string("language_gt")
    t.string("language_gte")
    t.string("language_contains")
    t.string("language_not_contains")
    t.string("language_starts_with")
    t.string("language_not_starts_with")
    t.string("language_ends_with")
    t.string("language_not_ends_with")
    t.field("translation", { type: TranslationWhereInput })
    t.string("slug")
    t.string("slug_not")
    t.list.nonNull.string("slug_in")
    t.list.nonNull.string("slug_not_in")
    t.string("slug_lt")
    t.string("slug_lte")
    t.string("slug_gt")
    t.string("slug_gte")
    t.string("slug_contains")
    t.string("slug_not_contains")
    t.string("slug_starts_with")
    t.string("slug_not_starts_with")
    t.string("slug_ends_with")
    t.string("slug_not_ends_with")
    t.int("views")
    t.int("views_not")
    t.list.nonNull.int("views_in")
    t.list.nonNull.int("views_not_in")
    t.int("views_lt")
    t.int("views_lte")
    t.int("views_gt")
    t.int("views_gte")
    t.field("node", { type: ZNodeWhereInput })
    t.field("user", { type: UserWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: QuestionWhereInput })
    t.list.nonNull.field("OR", { type: QuestionWhereInput })
    t.list.nonNull.field("NOT", { type: QuestionWhereInput })
  }
});
const QuestionWhereUniqueInput = inputObjectType({
  name: "QuestionWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const SourceCreateInput = inputObjectType({
  name: "SourceCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("label")
    t.nonNull.string("url")
    t.nonNull.field("answer", { type: AnswerCreateOneWithoutSourcesInput })
  }
});
const SourceCreateManyWithoutAnswerInput = inputObjectType({
  name: "SourceCreateManyWithoutAnswerInput",
  definition(t) {
    t.list.nonNull.field("create", { type: SourceCreateWithoutAnswerInput })
    t.list.nonNull.field("connect", { type: SourceWhereUniqueInput })
  }
});
const SourceCreateWithoutAnswerInput = inputObjectType({
  name: "SourceCreateWithoutAnswerInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("label")
    t.nonNull.string("url")
  }
});
const SourceScalarWhereInput = inputObjectType({
  name: "SourceScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("label")
    t.string("label_not")
    t.list.nonNull.string("label_in")
    t.list.nonNull.string("label_not_in")
    t.string("label_lt")
    t.string("label_lte")
    t.string("label_gt")
    t.string("label_gte")
    t.string("label_contains")
    t.string("label_not_contains")
    t.string("label_starts_with")
    t.string("label_not_starts_with")
    t.string("label_ends_with")
    t.string("label_not_ends_with")
    t.string("url")
    t.string("url_not")
    t.list.nonNull.string("url_in")
    t.list.nonNull.string("url_not_in")
    t.string("url_lt")
    t.string("url_lte")
    t.string("url_gt")
    t.string("url_gte")
    t.string("url_contains")
    t.string("url_not_contains")
    t.string("url_starts_with")
    t.string("url_not_starts_with")
    t.string("url_ends_with")
    t.string("url_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: SourceScalarWhereInput })
    t.list.nonNull.field("OR", { type: SourceScalarWhereInput })
    t.list.nonNull.field("NOT", { type: SourceScalarWhereInput })
  }
});
const SourceSubscriptionWhereInput = inputObjectType({
  name: "SourceSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: SourceWhereInput })
    t.list.nonNull.field("AND", { type: SourceSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: SourceSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: SourceSubscriptionWhereInput })
  }
});
const SourceUpdateInput = inputObjectType({
  name: "SourceUpdateInput",
  definition(t) {
    t.string("label")
    t.string("url")
    t.field("answer", { type: AnswerUpdateOneRequiredWithoutSourcesInput })
  }
});
const SourceUpdateManyDataInput = inputObjectType({
  name: "SourceUpdateManyDataInput",
  definition(t) {
    t.string("label")
    t.string("url")
  }
});
const SourceUpdateManyMutationInput = inputObjectType({
  name: "SourceUpdateManyMutationInput",
  definition(t) {
    t.string("label")
    t.string("url")
  }
});
const SourceUpdateManyWithWhereNestedInput = inputObjectType({
  name: "SourceUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: SourceScalarWhereInput })
    t.nonNull.field("data", { type: SourceUpdateManyDataInput })
  }
});
const SourceUpdateManyWithoutAnswerInput = inputObjectType({
  name: "SourceUpdateManyWithoutAnswerInput",
  definition(t) {
    t.list.nonNull.field("create", { type: SourceCreateWithoutAnswerInput })
    t.list.nonNull.field("delete", { type: SourceWhereUniqueInput })
    t.list.nonNull.field("connect", { type: SourceWhereUniqueInput })
    t.list.nonNull.field("set", { type: SourceWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: SourceWhereUniqueInput })
    t.list.nonNull.field("update", { type: SourceUpdateWithWhereUniqueWithoutAnswerInput })
    t.list.nonNull.field("upsert", { type: SourceUpsertWithWhereUniqueWithoutAnswerInput })
    t.list.nonNull.field("deleteMany", { type: SourceScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: SourceUpdateManyWithWhereNestedInput })
  }
});
const SourceUpdateWithWhereUniqueWithoutAnswerInput = inputObjectType({
  name: "SourceUpdateWithWhereUniqueWithoutAnswerInput",
  definition(t) {
    t.nonNull.field("where", { type: SourceWhereUniqueInput })
    t.nonNull.field("data", { type: SourceUpdateWithoutAnswerDataInput })
  }
});
const SourceUpdateWithoutAnswerDataInput = inputObjectType({
  name: "SourceUpdateWithoutAnswerDataInput",
  definition(t) {
    t.string("label")
    t.string("url")
  }
});
const SourceUpsertWithWhereUniqueWithoutAnswerInput = inputObjectType({
  name: "SourceUpsertWithWhereUniqueWithoutAnswerInput",
  definition(t) {
    t.nonNull.field("where", { type: SourceWhereUniqueInput })
    t.nonNull.field("update", { type: SourceUpdateWithoutAnswerDataInput })
    t.nonNull.field("create", { type: SourceCreateWithoutAnswerInput })
  }
});
const SourceWhereInput = inputObjectType({
  name: "SourceWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("label")
    t.string("label_not")
    t.list.nonNull.string("label_in")
    t.list.nonNull.string("label_not_in")
    t.string("label_lt")
    t.string("label_lte")
    t.string("label_gt")
    t.string("label_gte")
    t.string("label_contains")
    t.string("label_not_contains")
    t.string("label_starts_with")
    t.string("label_not_starts_with")
    t.string("label_ends_with")
    t.string("label_not_ends_with")
    t.string("url")
    t.string("url_not")
    t.list.nonNull.string("url_in")
    t.list.nonNull.string("url_not_in")
    t.string("url_lt")
    t.string("url_lte")
    t.string("url_gt")
    t.string("url_gte")
    t.string("url_contains")
    t.string("url_not_contains")
    t.string("url_starts_with")
    t.string("url_not_starts_with")
    t.string("url_ends_with")
    t.string("url_not_ends_with")
    t.field("answer", { type: AnswerWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: SourceWhereInput })
    t.list.nonNull.field("OR", { type: SourceWhereInput })
    t.list.nonNull.field("NOT", { type: SourceWhereInput })
  }
});
const SourceWhereUniqueInput = inputObjectType({
  name: "SourceWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const TagCategoryCreateInput = inputObjectType({
  name: "TagCategoryCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("labels", { type: TagLabelCreateManyWithoutCategoryInput })
    t.nonNull.int("order")
    t.nonNull.field("configuration", { type: ConfigurationCreateOneWithoutTagCategoriesInput })
  }
});
const TagCategoryCreateManyWithoutConfigurationInput = inputObjectType({
  name: "TagCategoryCreateManyWithoutConfigurationInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCategoryCreateWithoutConfigurationInput })
    t.list.nonNull.field("connect", { type: TagCategoryWhereUniqueInput })
  }
});
const TagCategoryCreateOneWithoutLabelsInput = inputObjectType({
  name: "TagCategoryCreateOneWithoutLabelsInput",
  definition(t) {
    t.field("create", { type: TagCategoryCreateWithoutLabelsInput })
    t.field("connect", { type: TagCategoryWhereUniqueInput })
  }
});
const TagCategoryCreateWithoutConfigurationInput = inputObjectType({
  name: "TagCategoryCreateWithoutConfigurationInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("labels", { type: TagLabelCreateManyWithoutCategoryInput })
    t.nonNull.int("order")
  }
});
const TagCategoryCreateWithoutLabelsInput = inputObjectType({
  name: "TagCategoryCreateWithoutLabelsInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.nonNull.int("order")
    t.nonNull.field("configuration", { type: ConfigurationCreateOneWithoutTagCategoriesInput })
  }
});
const TagCategoryScalarWhereInput = inputObjectType({
  name: "TagCategoryScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.int("order")
    t.int("order_not")
    t.list.nonNull.int("order_in")
    t.list.nonNull.int("order_not_in")
    t.int("order_lt")
    t.int("order_lte")
    t.int("order_gt")
    t.int("order_gte")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagCategoryScalarWhereInput })
    t.list.nonNull.field("OR", { type: TagCategoryScalarWhereInput })
    t.list.nonNull.field("NOT", { type: TagCategoryScalarWhereInput })
  }
});
const TagCategorySubscriptionWhereInput = inputObjectType({
  name: "TagCategorySubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: TagCategoryWhereInput })
    t.list.nonNull.field("AND", { type: TagCategorySubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: TagCategorySubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: TagCategorySubscriptionWhereInput })
  }
});
const TagCategoryUpdateInput = inputObjectType({
  name: "TagCategoryUpdateInput",
  definition(t) {
    t.string("name")
    t.field("labels", { type: TagLabelUpdateManyWithoutCategoryInput })
    t.int("order")
    t.field("configuration", { type: ConfigurationUpdateOneRequiredWithoutTagCategoriesInput })
  }
});
const TagCategoryUpdateManyDataInput = inputObjectType({
  name: "TagCategoryUpdateManyDataInput",
  definition(t) {
    t.string("name")
    t.int("order")
  }
});
const TagCategoryUpdateManyMutationInput = inputObjectType({
  name: "TagCategoryUpdateManyMutationInput",
  definition(t) {
    t.string("name")
    t.int("order")
  }
});
const TagCategoryUpdateManyWithWhereNestedInput = inputObjectType({
  name: "TagCategoryUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: TagCategoryScalarWhereInput })
    t.nonNull.field("data", { type: TagCategoryUpdateManyDataInput })
  }
});
const TagCategoryUpdateManyWithoutConfigurationInput = inputObjectType({
  name: "TagCategoryUpdateManyWithoutConfigurationInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCategoryCreateWithoutConfigurationInput })
    t.list.nonNull.field("delete", { type: TagCategoryWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagCategoryWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagCategoryWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagCategoryWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagCategoryUpdateWithWhereUniqueWithoutConfigurationInput })
    t.list.nonNull.field("upsert", { type: TagCategoryUpsertWithWhereUniqueWithoutConfigurationInput })
    t.list.nonNull.field("deleteMany", { type: TagCategoryScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: TagCategoryUpdateManyWithWhereNestedInput })
  }
});
const TagCategoryUpdateOneRequiredWithoutLabelsInput = inputObjectType({
  name: "TagCategoryUpdateOneRequiredWithoutLabelsInput",
  definition(t) {
    t.field("create", { type: TagCategoryCreateWithoutLabelsInput })
    t.field("update", { type: TagCategoryUpdateWithoutLabelsDataInput })
    t.field("upsert", { type: TagCategoryUpsertWithoutLabelsInput })
    t.field("connect", { type: TagCategoryWhereUniqueInput })
  }
});
const TagCategoryUpdateWithWhereUniqueWithoutConfigurationInput = inputObjectType({
  name: "TagCategoryUpdateWithWhereUniqueWithoutConfigurationInput",
  definition(t) {
    t.nonNull.field("where", { type: TagCategoryWhereUniqueInput })
    t.nonNull.field("data", { type: TagCategoryUpdateWithoutConfigurationDataInput })
  }
});
const TagCategoryUpdateWithoutConfigurationDataInput = inputObjectType({
  name: "TagCategoryUpdateWithoutConfigurationDataInput",
  definition(t) {
    t.string("name")
    t.field("labels", { type: TagLabelUpdateManyWithoutCategoryInput })
    t.int("order")
  }
});
const TagCategoryUpdateWithoutLabelsDataInput = inputObjectType({
  name: "TagCategoryUpdateWithoutLabelsDataInput",
  definition(t) {
    t.string("name")
    t.int("order")
    t.field("configuration", { type: ConfigurationUpdateOneRequiredWithoutTagCategoriesInput })
  }
});
const TagCategoryUpsertWithWhereUniqueWithoutConfigurationInput = inputObjectType({
  name: "TagCategoryUpsertWithWhereUniqueWithoutConfigurationInput",
  definition(t) {
    t.nonNull.field("where", { type: TagCategoryWhereUniqueInput })
    t.nonNull.field("update", { type: TagCategoryUpdateWithoutConfigurationDataInput })
    t.nonNull.field("create", { type: TagCategoryCreateWithoutConfigurationInput })
  }
});
const TagCategoryUpsertWithoutLabelsInput = inputObjectType({
  name: "TagCategoryUpsertWithoutLabelsInput",
  definition(t) {
    t.nonNull.field("update", { type: TagCategoryUpdateWithoutLabelsDataInput })
    t.nonNull.field("create", { type: TagCategoryCreateWithoutLabelsInput })
  }
});
const TagCategoryWhereInput = inputObjectType({
  name: "TagCategoryWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.field("labels_every", { type: TagLabelWhereInput })
    t.field("labels_some", { type: TagLabelWhereInput })
    t.field("labels_none", { type: TagLabelWhereInput })
    t.int("order")
    t.int("order_not")
    t.list.nonNull.int("order_in")
    t.list.nonNull.int("order_not_in")
    t.int("order_lt")
    t.int("order_lte")
    t.int("order_gt")
    t.int("order_gte")
    t.field("configuration", { type: ConfigurationWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagCategoryWhereInput })
    t.list.nonNull.field("OR", { type: TagCategoryWhereInput })
    t.list.nonNull.field("NOT", { type: TagCategoryWhereInput })
  }
});
const TagCategoryWhereUniqueInput = inputObjectType({
  name: "TagCategoryWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const TagCreateInput = inputObjectType({
  name: "TagCreateInput",
  definition(t) {
    t.id("id")
    t.field("label", { type: TagLabelCreateOneWithoutTagsInput })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutTagsInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutTagsInput })
  }
});
const TagCreateManyWithoutLabelInput = inputObjectType({
  name: "TagCreateManyWithoutLabelInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutLabelInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
  }
});
const TagCreateManyWithoutNodeInput = inputObjectType({
  name: "TagCreateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutNodeInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
  }
});
const TagCreateManyWithoutUserInput = inputObjectType({
  name: "TagCreateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutUserInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
  }
});
const TagCreateWithoutLabelInput = inputObjectType({
  name: "TagCreateWithoutLabelInput",
  definition(t) {
    t.id("id")
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutTagsInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutTagsInput })
  }
});
const TagCreateWithoutNodeInput = inputObjectType({
  name: "TagCreateWithoutNodeInput",
  definition(t) {
    t.id("id")
    t.field("label", { type: TagLabelCreateOneWithoutTagsInput })
    t.nonNull.field("user", { type: UserCreateOneWithoutTagsInput })
  }
});
const TagCreateWithoutUserInput = inputObjectType({
  name: "TagCreateWithoutUserInput",
  definition(t) {
    t.id("id")
    t.field("label", { type: TagLabelCreateOneWithoutTagsInput })
    t.nonNull.field("node", { type: ZNodeCreateOneWithoutTagsInput })
  }
});
const TagLabelCreateInput = inputObjectType({
  name: "TagLabelCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("tags", { type: TagCreateManyWithoutLabelInput })
    t.field("specialists", { type: UserCreateManyWithoutSpecialtiesInput })
    t.nonNull.int("order")
    t.nonNull.field("category", { type: TagCategoryCreateOneWithoutLabelsInput })
  }
});
const TagLabelCreateManyWithoutCategoryInput = inputObjectType({
  name: "TagLabelCreateManyWithoutCategoryInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagLabelCreateWithoutCategoryInput })
    t.list.nonNull.field("connect", { type: TagLabelWhereUniqueInput })
  }
});
const TagLabelCreateManyWithoutSpecialistsInput = inputObjectType({
  name: "TagLabelCreateManyWithoutSpecialistsInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagLabelCreateWithoutSpecialistsInput })
    t.list.nonNull.field("connect", { type: TagLabelWhereUniqueInput })
  }
});
const TagLabelCreateOneWithoutTagsInput = inputObjectType({
  name: "TagLabelCreateOneWithoutTagsInput",
  definition(t) {
    t.field("create", { type: TagLabelCreateWithoutTagsInput })
    t.field("connect", { type: TagLabelWhereUniqueInput })
  }
});
const TagLabelCreateWithoutCategoryInput = inputObjectType({
  name: "TagLabelCreateWithoutCategoryInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("tags", { type: TagCreateManyWithoutLabelInput })
    t.field("specialists", { type: UserCreateManyWithoutSpecialtiesInput })
    t.nonNull.int("order")
  }
});
const TagLabelCreateWithoutSpecialistsInput = inputObjectType({
  name: "TagLabelCreateWithoutSpecialistsInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("tags", { type: TagCreateManyWithoutLabelInput })
    t.nonNull.int("order")
    t.nonNull.field("category", { type: TagCategoryCreateOneWithoutLabelsInput })
  }
});
const TagLabelCreateWithoutTagsInput = inputObjectType({
  name: "TagLabelCreateWithoutTagsInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("name")
    t.field("specialists", { type: UserCreateManyWithoutSpecialtiesInput })
    t.nonNull.int("order")
    t.nonNull.field("category", { type: TagCategoryCreateOneWithoutLabelsInput })
  }
});
const TagLabelScalarWhereInput = inputObjectType({
  name: "TagLabelScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.int("order")
    t.int("order_not")
    t.list.nonNull.int("order_in")
    t.list.nonNull.int("order_not_in")
    t.int("order_lt")
    t.int("order_lte")
    t.int("order_gt")
    t.int("order_gte")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagLabelScalarWhereInput })
    t.list.nonNull.field("OR", { type: TagLabelScalarWhereInput })
    t.list.nonNull.field("NOT", { type: TagLabelScalarWhereInput })
  }
});
const TagLabelSubscriptionWhereInput = inputObjectType({
  name: "TagLabelSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: TagLabelWhereInput })
    t.list.nonNull.field("AND", { type: TagLabelSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: TagLabelSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: TagLabelSubscriptionWhereInput })
  }
});
const TagLabelUpdateInput = inputObjectType({
  name: "TagLabelUpdateInput",
  definition(t) {
    t.string("name")
    t.field("tags", { type: TagUpdateManyWithoutLabelInput })
    t.field("specialists", { type: UserUpdateManyWithoutSpecialtiesInput })
    t.int("order")
    t.field("category", { type: TagCategoryUpdateOneRequiredWithoutLabelsInput })
  }
});
const TagLabelUpdateManyDataInput = inputObjectType({
  name: "TagLabelUpdateManyDataInput",
  definition(t) {
    t.string("name")
    t.int("order")
  }
});
const TagLabelUpdateManyMutationInput = inputObjectType({
  name: "TagLabelUpdateManyMutationInput",
  definition(t) {
    t.string("name")
    t.int("order")
  }
});
const TagLabelUpdateManyWithWhereNestedInput = inputObjectType({
  name: "TagLabelUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: TagLabelScalarWhereInput })
    t.nonNull.field("data", { type: TagLabelUpdateManyDataInput })
  }
});
const TagLabelUpdateManyWithoutCategoryInput = inputObjectType({
  name: "TagLabelUpdateManyWithoutCategoryInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagLabelCreateWithoutCategoryInput })
    t.list.nonNull.field("delete", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagLabelUpdateWithWhereUniqueWithoutCategoryInput })
    t.list.nonNull.field("upsert", { type: TagLabelUpsertWithWhereUniqueWithoutCategoryInput })
    t.list.nonNull.field("deleteMany", { type: TagLabelScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: TagLabelUpdateManyWithWhereNestedInput })
  }
});
const TagLabelUpdateManyWithoutSpecialistsInput = inputObjectType({
  name: "TagLabelUpdateManyWithoutSpecialistsInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagLabelCreateWithoutSpecialistsInput })
    t.list.nonNull.field("delete", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagLabelWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagLabelUpdateWithWhereUniqueWithoutSpecialistsInput })
    t.list.nonNull.field("upsert", { type: TagLabelUpsertWithWhereUniqueWithoutSpecialistsInput })
    t.list.nonNull.field("deleteMany", { type: TagLabelScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: TagLabelUpdateManyWithWhereNestedInput })
  }
});
const TagLabelUpdateOneWithoutTagsInput = inputObjectType({
  name: "TagLabelUpdateOneWithoutTagsInput",
  definition(t) {
    t.field("create", { type: TagLabelCreateWithoutTagsInput })
    t.field("update", { type: TagLabelUpdateWithoutTagsDataInput })
    t.field("upsert", { type: TagLabelUpsertWithoutTagsInput })
    t.boolean("delete")
    t.boolean("disconnect")
    t.field("connect", { type: TagLabelWhereUniqueInput })
  }
});
const TagLabelUpdateWithWhereUniqueWithoutCategoryInput = inputObjectType({
  name: "TagLabelUpdateWithWhereUniqueWithoutCategoryInput",
  definition(t) {
    t.nonNull.field("where", { type: TagLabelWhereUniqueInput })
    t.nonNull.field("data", { type: TagLabelUpdateWithoutCategoryDataInput })
  }
});
const TagLabelUpdateWithWhereUniqueWithoutSpecialistsInput = inputObjectType({
  name: "TagLabelUpdateWithWhereUniqueWithoutSpecialistsInput",
  definition(t) {
    t.nonNull.field("where", { type: TagLabelWhereUniqueInput })
    t.nonNull.field("data", { type: TagLabelUpdateWithoutSpecialistsDataInput })
  }
});
const TagLabelUpdateWithoutCategoryDataInput = inputObjectType({
  name: "TagLabelUpdateWithoutCategoryDataInput",
  definition(t) {
    t.string("name")
    t.field("tags", { type: TagUpdateManyWithoutLabelInput })
    t.field("specialists", { type: UserUpdateManyWithoutSpecialtiesInput })
    t.int("order")
  }
});
const TagLabelUpdateWithoutSpecialistsDataInput = inputObjectType({
  name: "TagLabelUpdateWithoutSpecialistsDataInput",
  definition(t) {
    t.string("name")
    t.field("tags", { type: TagUpdateManyWithoutLabelInput })
    t.int("order")
    t.field("category", { type: TagCategoryUpdateOneRequiredWithoutLabelsInput })
  }
});
const TagLabelUpdateWithoutTagsDataInput = inputObjectType({
  name: "TagLabelUpdateWithoutTagsDataInput",
  definition(t) {
    t.string("name")
    t.field("specialists", { type: UserUpdateManyWithoutSpecialtiesInput })
    t.int("order")
    t.field("category", { type: TagCategoryUpdateOneRequiredWithoutLabelsInput })
  }
});
const TagLabelUpsertWithWhereUniqueWithoutCategoryInput = inputObjectType({
  name: "TagLabelUpsertWithWhereUniqueWithoutCategoryInput",
  definition(t) {
    t.nonNull.field("where", { type: TagLabelWhereUniqueInput })
    t.nonNull.field("update", { type: TagLabelUpdateWithoutCategoryDataInput })
    t.nonNull.field("create", { type: TagLabelCreateWithoutCategoryInput })
  }
});
const TagLabelUpsertWithWhereUniqueWithoutSpecialistsInput = inputObjectType({
  name: "TagLabelUpsertWithWhereUniqueWithoutSpecialistsInput",
  definition(t) {
    t.nonNull.field("where", { type: TagLabelWhereUniqueInput })
    t.nonNull.field("update", { type: TagLabelUpdateWithoutSpecialistsDataInput })
    t.nonNull.field("create", { type: TagLabelCreateWithoutSpecialistsInput })
  }
});
const TagLabelUpsertWithoutTagsInput = inputObjectType({
  name: "TagLabelUpsertWithoutTagsInput",
  definition(t) {
    t.nonNull.field("update", { type: TagLabelUpdateWithoutTagsDataInput })
    t.nonNull.field("create", { type: TagLabelCreateWithoutTagsInput })
  }
});
const TagLabelWhereInput = inputObjectType({
  name: "TagLabelWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.field("tags_every", { type: TagWhereInput })
    t.field("tags_some", { type: TagWhereInput })
    t.field("tags_none", { type: TagWhereInput })
    t.field("specialists_every", { type: UserWhereInput })
    t.field("specialists_some", { type: UserWhereInput })
    t.field("specialists_none", { type: UserWhereInput })
    t.int("order")
    t.int("order_not")
    t.list.nonNull.int("order_in")
    t.list.nonNull.int("order_not_in")
    t.int("order_lt")
    t.int("order_lte")
    t.int("order_gt")
    t.int("order_gte")
    t.field("category", { type: TagCategoryWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagLabelWhereInput })
    t.list.nonNull.field("OR", { type: TagLabelWhereInput })
    t.list.nonNull.field("NOT", { type: TagLabelWhereInput })
  }
});
const TagLabelWhereUniqueInput = inputObjectType({
  name: "TagLabelWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const TagScalarWhereInput = inputObjectType({
  name: "TagScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagScalarWhereInput })
    t.list.nonNull.field("OR", { type: TagScalarWhereInput })
    t.list.nonNull.field("NOT", { type: TagScalarWhereInput })
  }
});
const TagSubscriptionWhereInput = inputObjectType({
  name: "TagSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: TagWhereInput })
    t.list.nonNull.field("AND", { type: TagSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: TagSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: TagSubscriptionWhereInput })
  }
});
const TagUpdateInput = inputObjectType({
  name: "TagUpdateInput",
  definition(t) {
    t.field("label", { type: TagLabelUpdateOneWithoutTagsInput })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutTagsInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutTagsInput })
  }
});
const TagUpdateManyWithoutLabelInput = inputObjectType({
  name: "TagUpdateManyWithoutLabelInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutLabelInput })
    t.list.nonNull.field("delete", { type: TagWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagUpdateWithWhereUniqueWithoutLabelInput })
    t.list.nonNull.field("upsert", { type: TagUpsertWithWhereUniqueWithoutLabelInput })
    t.list.nonNull.field("deleteMany", { type: TagScalarWhereInput })
  }
});
const TagUpdateManyWithoutNodeInput = inputObjectType({
  name: "TagUpdateManyWithoutNodeInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutNodeInput })
    t.list.nonNull.field("delete", { type: TagWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagUpdateWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("upsert", { type: TagUpsertWithWhereUniqueWithoutNodeInput })
    t.list.nonNull.field("deleteMany", { type: TagScalarWhereInput })
  }
});
const TagUpdateManyWithoutUserInput = inputObjectType({
  name: "TagUpdateManyWithoutUserInput",
  definition(t) {
    t.list.nonNull.field("create", { type: TagCreateWithoutUserInput })
    t.list.nonNull.field("delete", { type: TagWhereUniqueInput })
    t.list.nonNull.field("connect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("set", { type: TagWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: TagWhereUniqueInput })
    t.list.nonNull.field("update", { type: TagUpdateWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("upsert", { type: TagUpsertWithWhereUniqueWithoutUserInput })
    t.list.nonNull.field("deleteMany", { type: TagScalarWhereInput })
  }
});
const TagUpdateWithWhereUniqueWithoutLabelInput = inputObjectType({
  name: "TagUpdateWithWhereUniqueWithoutLabelInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("data", { type: TagUpdateWithoutLabelDataInput })
  }
});
const TagUpdateWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "TagUpdateWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("data", { type: TagUpdateWithoutNodeDataInput })
  }
});
const TagUpdateWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "TagUpdateWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("data", { type: TagUpdateWithoutUserDataInput })
  }
});
const TagUpdateWithoutLabelDataInput = inputObjectType({
  name: "TagUpdateWithoutLabelDataInput",
  definition(t) {
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutTagsInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutTagsInput })
  }
});
const TagUpdateWithoutNodeDataInput = inputObjectType({
  name: "TagUpdateWithoutNodeDataInput",
  definition(t) {
    t.field("label", { type: TagLabelUpdateOneWithoutTagsInput })
    t.field("user", { type: UserUpdateOneRequiredWithoutTagsInput })
  }
});
const TagUpdateWithoutUserDataInput = inputObjectType({
  name: "TagUpdateWithoutUserDataInput",
  definition(t) {
    t.field("label", { type: TagLabelUpdateOneWithoutTagsInput })
    t.field("node", { type: ZNodeUpdateOneRequiredWithoutTagsInput })
  }
});
const TagUpsertWithWhereUniqueWithoutLabelInput = inputObjectType({
  name: "TagUpsertWithWhereUniqueWithoutLabelInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("update", { type: TagUpdateWithoutLabelDataInput })
    t.nonNull.field("create", { type: TagCreateWithoutLabelInput })
  }
});
const TagUpsertWithWhereUniqueWithoutNodeInput = inputObjectType({
  name: "TagUpsertWithWhereUniqueWithoutNodeInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("update", { type: TagUpdateWithoutNodeDataInput })
    t.nonNull.field("create", { type: TagCreateWithoutNodeInput })
  }
});
const TagUpsertWithWhereUniqueWithoutUserInput = inputObjectType({
  name: "TagUpsertWithWhereUniqueWithoutUserInput",
  definition(t) {
    t.nonNull.field("where", { type: TagWhereUniqueInput })
    t.nonNull.field("update", { type: TagUpdateWithoutUserDataInput })
    t.nonNull.field("create", { type: TagCreateWithoutUserInput })
  }
});
const TagWhereInput = inputObjectType({
  name: "TagWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.field("label", { type: TagLabelWhereInput })
    t.field("node", { type: ZNodeWhereInput })
    t.field("user", { type: UserWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: TagWhereInput })
    t.list.nonNull.field("OR", { type: TagWhereInput })
    t.list.nonNull.field("NOT", { type: TagWhereInput })
  }
});
const TagWhereUniqueInput = inputObjectType({
  name: "TagWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const TranslationCreateInput = inputObjectType({
  name: "TranslationCreateInput",
  definition(t) {
    t.id("id")
    t.nonNull.string("language")
    t.nonNull.string("text")
  }
});
const TranslationCreateOneInput = inputObjectType({
  name: "TranslationCreateOneInput",
  definition(t) {
    t.field("create", { type: TranslationCreateInput })
    t.field("connect", { type: TranslationWhereUniqueInput })
  }
});
const TranslationSubscriptionWhereInput = inputObjectType({
  name: "TranslationSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: TranslationWhereInput })
    t.list.nonNull.field("AND", { type: TranslationSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: TranslationSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: TranslationSubscriptionWhereInput })
  }
});
const TranslationUpdateDataInput = inputObjectType({
  name: "TranslationUpdateDataInput",
  definition(t) {
    t.string("language")
    t.string("text")
  }
});
const TranslationUpdateInput = inputObjectType({
  name: "TranslationUpdateInput",
  definition(t) {
    t.string("language")
    t.string("text")
  }
});
const TranslationUpdateManyMutationInput = inputObjectType({
  name: "TranslationUpdateManyMutationInput",
  definition(t) {
    t.string("language")
    t.string("text")
  }
});
const TranslationUpdateOneInput = inputObjectType({
  name: "TranslationUpdateOneInput",
  definition(t) {
    t.field("create", { type: TranslationCreateInput })
    t.field("update", { type: TranslationUpdateDataInput })
    t.field("upsert", { type: TranslationUpsertNestedInput })
    t.boolean("delete")
    t.boolean("disconnect")
    t.field("connect", { type: TranslationWhereUniqueInput })
  }
});
const TranslationUpsertNestedInput = inputObjectType({
  name: "TranslationUpsertNestedInput",
  definition(t) {
    t.nonNull.field("update", { type: TranslationUpdateDataInput })
    t.nonNull.field("create", { type: TranslationCreateInput })
  }
});
const TranslationWhereInput = inputObjectType({
  name: "TranslationWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("language")
    t.string("language_not")
    t.list.nonNull.string("language_in")
    t.list.nonNull.string("language_not_in")
    t.string("language_lt")
    t.string("language_lte")
    t.string("language_gt")
    t.string("language_gte")
    t.string("language_contains")
    t.string("language_not_contains")
    t.string("language_starts_with")
    t.string("language_not_starts_with")
    t.string("language_ends_with")
    t.string("language_not_ends_with")
    t.string("text")
    t.string("text_not")
    t.list.nonNull.string("text_in")
    t.list.nonNull.string("text_not_in")
    t.string("text_lt")
    t.string("text_lte")
    t.string("text_gt")
    t.string("text_gte")
    t.string("text_contains")
    t.string("text_not_contains")
    t.string("text_starts_with")
    t.string("text_not_starts_with")
    t.string("text_ends_with")
    t.string("text_not_ends_with")
    t.list.nonNull.field("AND", { type: TranslationWhereInput })
    t.list.nonNull.field("OR", { type: TranslationWhereInput })
    t.list.nonNull.field("NOT", { type: TranslationWhereInput })
  }
});
const TranslationWhereUniqueInput = inputObjectType({
  name: "TranslationWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});
const UserCreateInput = inputObjectType({
  name: "UserCreateInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserCreateManyWithoutSpecialtiesInput = inputObjectType({
  name: "UserCreateManyWithoutSpecialtiesInput",
  definition(t) {
    t.list.nonNull.field("create", { type: UserCreateWithoutSpecialtiesInput })
    t.list.nonNull.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateOneWithoutAnswersInput = inputObjectType({
  name: "UserCreateOneWithoutAnswersInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutAnswersInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateOneWithoutFlagsInput = inputObjectType({
  name: "UserCreateOneWithoutFlagsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutFlagsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateOneWithoutHistoryInput = inputObjectType({
  name: "UserCreateOneWithoutHistoryInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutHistoryInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateOneWithoutQuestionsInput = inputObjectType({
  name: "UserCreateOneWithoutQuestionsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutQuestionsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateOneWithoutTagsInput = inputObjectType({
  name: "UserCreateOneWithoutTagsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutTagsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserCreateWithoutAnswersInput = inputObjectType({
  name: "UserCreateWithoutAnswersInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserCreateWithoutFlagsInput = inputObjectType({
  name: "UserCreateWithoutFlagsInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserCreateWithoutHistoryInput = inputObjectType({
  name: "UserCreateWithoutHistoryInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
  }
});
const UserCreateWithoutQuestionsInput = inputObjectType({
  name: "UserCreateWithoutQuestionsInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserCreateWithoutSpecialtiesInput = inputObjectType({
  name: "UserCreateWithoutSpecialtiesInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("tags", { type: TagCreateManyWithoutUserInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserCreateWithoutTagsInput = inputObjectType({
  name: "UserCreateWithoutTagsInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionCreateManyWithoutUserInput })
    t.field("answers", { type: AnswerCreateManyWithoutUserInput })
    t.field("flags", { type: FlagCreateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelCreateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionCreateManyWithoutUserInput })
  }
});
const UserScalarWhereInput = inputObjectType({
  name: "UserScalarWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("auth0Id")
    t.string("auth0Id_not")
    t.list.nonNull.string("auth0Id_in")
    t.list.nonNull.string("auth0Id_not_in")
    t.string("auth0Id_lt")
    t.string("auth0Id_lte")
    t.string("auth0Id_gt")
    t.string("auth0Id_gte")
    t.string("auth0Id_contains")
    t.string("auth0Id_not_contains")
    t.string("auth0Id_starts_with")
    t.string("auth0Id_not_starts_with")
    t.string("auth0Id_ends_with")
    t.string("auth0Id_not_ends_with")
    t.string("key")
    t.string("key_not")
    t.list.nonNull.string("key_in")
    t.list.nonNull.string("key_not_in")
    t.string("key_lt")
    t.string("key_lte")
    t.string("key_gt")
    t.string("key_gte")
    t.string("key_contains")
    t.string("key_not_contains")
    t.string("key_starts_with")
    t.string("key_not_starts_with")
    t.string("key_ends_with")
    t.string("key_not_ends_with")
    t.boolean("admin")
    t.boolean("admin_not")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.string("email")
    t.string("email_not")
    t.list.nonNull.string("email_in")
    t.list.nonNull.string("email_not_in")
    t.string("email_lt")
    t.string("email_lte")
    t.string("email_gt")
    t.string("email_gte")
    t.string("email_contains")
    t.string("email_not_contains")
    t.string("email_starts_with")
    t.string("email_not_starts_with")
    t.string("email_ends_with")
    t.string("email_not_ends_with")
    t.string("picture")
    t.string("picture_not")
    t.list.nonNull.string("picture_in")
    t.list.nonNull.string("picture_not_in")
    t.string("picture_lt")
    t.string("picture_lte")
    t.string("picture_gt")
    t.string("picture_gte")
    t.string("picture_contains")
    t.string("picture_not_contains")
    t.string("picture_starts_with")
    t.string("picture_not_starts_with")
    t.string("picture_ends_with")
    t.string("picture_not_ends_with")
    t.string("locale")
    t.string("locale_not")
    t.list.nonNull.string("locale_in")
    t.list.nonNull.string("locale_not_in")
    t.string("locale_lt")
    t.string("locale_lte")
    t.string("locale_gt")
    t.string("locale_gte")
    t.string("locale_contains")
    t.string("locale_not_contains")
    t.string("locale_starts_with")
    t.string("locale_not_starts_with")
    t.string("locale_ends_with")
    t.string("locale_not_ends_with")
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: UserScalarWhereInput })
    t.list.nonNull.field("OR", { type: UserScalarWhereInput })
    t.list.nonNull.field("NOT", { type: UserScalarWhereInput })
  }
});
const UserSubscriptionWhereInput = inputObjectType({
  name: "UserSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: UserWhereInput })
    t.list.nonNull.field("AND", { type: UserSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: UserSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: UserSubscriptionWhereInput })
  }
});
const UserUpdateInput = inputObjectType({
  name: "UserUpdateInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpdateManyDataInput = inputObjectType({
  name: "UserUpdateManyDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
  }
});
const UserUpdateManyMutationInput = inputObjectType({
  name: "UserUpdateManyMutationInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
  }
});
const UserUpdateManyWithWhereNestedInput = inputObjectType({
  name: "UserUpdateManyWithWhereNestedInput",
  definition(t) {
    t.nonNull.field("where", { type: UserScalarWhereInput })
    t.nonNull.field("data", { type: UserUpdateManyDataInput })
  }
});
const UserUpdateManyWithoutSpecialtiesInput = inputObjectType({
  name: "UserUpdateManyWithoutSpecialtiesInput",
  definition(t) {
    t.list.nonNull.field("create", { type: UserCreateWithoutSpecialtiesInput })
    t.list.nonNull.field("delete", { type: UserWhereUniqueInput })
    t.list.nonNull.field("connect", { type: UserWhereUniqueInput })
    t.list.nonNull.field("set", { type: UserWhereUniqueInput })
    t.list.nonNull.field("disconnect", { type: UserWhereUniqueInput })
    t.list.nonNull.field("update", { type: UserUpdateWithWhereUniqueWithoutSpecialtiesInput })
    t.list.nonNull.field("upsert", { type: UserUpsertWithWhereUniqueWithoutSpecialtiesInput })
    t.list.nonNull.field("deleteMany", { type: UserScalarWhereInput })
    t.list.nonNull.field("updateMany", { type: UserUpdateManyWithWhereNestedInput })
  }
});
const UserUpdateOneRequiredWithoutAnswersInput = inputObjectType({
  name: "UserUpdateOneRequiredWithoutAnswersInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutAnswersInput })
    t.field("update", { type: UserUpdateWithoutAnswersDataInput })
    t.field("upsert", { type: UserUpsertWithoutAnswersInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserUpdateOneRequiredWithoutFlagsInput = inputObjectType({
  name: "UserUpdateOneRequiredWithoutFlagsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutFlagsInput })
    t.field("update", { type: UserUpdateWithoutFlagsDataInput })
    t.field("upsert", { type: UserUpsertWithoutFlagsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserUpdateOneRequiredWithoutHistoryInput = inputObjectType({
  name: "UserUpdateOneRequiredWithoutHistoryInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutHistoryInput })
    t.field("update", { type: UserUpdateWithoutHistoryDataInput })
    t.field("upsert", { type: UserUpsertWithoutHistoryInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserUpdateOneRequiredWithoutQuestionsInput = inputObjectType({
  name: "UserUpdateOneRequiredWithoutQuestionsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutQuestionsInput })
    t.field("update", { type: UserUpdateWithoutQuestionsDataInput })
    t.field("upsert", { type: UserUpsertWithoutQuestionsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserUpdateOneRequiredWithoutTagsInput = inputObjectType({
  name: "UserUpdateOneRequiredWithoutTagsInput",
  definition(t) {
    t.field("create", { type: UserCreateWithoutTagsInput })
    t.field("update", { type: UserUpdateWithoutTagsDataInput })
    t.field("upsert", { type: UserUpsertWithoutTagsInput })
    t.field("connect", { type: UserWhereUniqueInput })
  }
});
const UserUpdateWithWhereUniqueWithoutSpecialtiesInput = inputObjectType({
  name: "UserUpdateWithWhereUniqueWithoutSpecialtiesInput",
  definition(t) {
    t.nonNull.field("where", { type: UserWhereUniqueInput })
    t.nonNull.field("data", { type: UserUpdateWithoutSpecialtiesDataInput })
  }
});
const UserUpdateWithoutAnswersDataInput = inputObjectType({
  name: "UserUpdateWithoutAnswersDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpdateWithoutFlagsDataInput = inputObjectType({
  name: "UserUpdateWithoutFlagsDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpdateWithoutHistoryDataInput = inputObjectType({
  name: "UserUpdateWithoutHistoryDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
  }
});
const UserUpdateWithoutQuestionsDataInput = inputObjectType({
  name: "UserUpdateWithoutQuestionsDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpdateWithoutSpecialtiesDataInput = inputObjectType({
  name: "UserUpdateWithoutSpecialtiesDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("tags", { type: TagUpdateManyWithoutUserInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpdateWithoutTagsDataInput = inputObjectType({
  name: "UserUpdateWithoutTagsDataInput",
  definition(t) {
    t.string("auth0Id")
    t.string("key")
    t.boolean("admin")
    t.string("name")
    t.string("email")
    t.string("picture")
    t.string("locale")
    t.field("questions", { type: QuestionUpdateManyWithoutUserInput })
    t.field("answers", { type: AnswerUpdateManyWithoutUserInput })
    t.field("flags", { type: FlagUpdateManyWithoutUserInput })
    t.field("specialties", { type: TagLabelUpdateManyWithoutSpecialistsInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutUserInput })
  }
});
const UserUpsertWithWhereUniqueWithoutSpecialtiesInput = inputObjectType({
  name: "UserUpsertWithWhereUniqueWithoutSpecialtiesInput",
  definition(t) {
    t.nonNull.field("where", { type: UserWhereUniqueInput })
    t.nonNull.field("update", { type: UserUpdateWithoutSpecialtiesDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutSpecialtiesInput })
  }
});
const UserUpsertWithoutAnswersInput = inputObjectType({
  name: "UserUpsertWithoutAnswersInput",
  definition(t) {
    t.nonNull.field("update", { type: UserUpdateWithoutAnswersDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutAnswersInput })
  }
});
const UserUpsertWithoutFlagsInput = inputObjectType({
  name: "UserUpsertWithoutFlagsInput",
  definition(t) {
    t.nonNull.field("update", { type: UserUpdateWithoutFlagsDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutFlagsInput })
  }
});
const UserUpsertWithoutHistoryInput = inputObjectType({
  name: "UserUpsertWithoutHistoryInput",
  definition(t) {
    t.nonNull.field("update", { type: UserUpdateWithoutHistoryDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutHistoryInput })
  }
});
const UserUpsertWithoutQuestionsInput = inputObjectType({
  name: "UserUpsertWithoutQuestionsInput",
  definition(t) {
    t.nonNull.field("update", { type: UserUpdateWithoutQuestionsDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutQuestionsInput })
  }
});
const UserUpsertWithoutTagsInput = inputObjectType({
  name: "UserUpsertWithoutTagsInput",
  definition(t) {
    t.nonNull.field("update", { type: UserUpdateWithoutTagsDataInput })
    t.nonNull.field("create", { type: UserCreateWithoutTagsInput })
  }
});
const UserWhereInput = inputObjectType({
  name: "UserWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.string("auth0Id")
    t.string("auth0Id_not")
    t.list.nonNull.string("auth0Id_in")
    t.list.nonNull.string("auth0Id_not_in")
    t.string("auth0Id_lt")
    t.string("auth0Id_lte")
    t.string("auth0Id_gt")
    t.string("auth0Id_gte")
    t.string("auth0Id_contains")
    t.string("auth0Id_not_contains")
    t.string("auth0Id_starts_with")
    t.string("auth0Id_not_starts_with")
    t.string("auth0Id_ends_with")
    t.string("auth0Id_not_ends_with")
    t.string("key")
    t.string("key_not")
    t.list.nonNull.string("key_in")
    t.list.nonNull.string("key_not_in")
    t.string("key_lt")
    t.string("key_lte")
    t.string("key_gt")
    t.string("key_gte")
    t.string("key_contains")
    t.string("key_not_contains")
    t.string("key_starts_with")
    t.string("key_not_starts_with")
    t.string("key_ends_with")
    t.string("key_not_ends_with")
    t.boolean("admin")
    t.boolean("admin_not")
    t.string("name")
    t.string("name_not")
    t.list.nonNull.string("name_in")
    t.list.nonNull.string("name_not_in")
    t.string("name_lt")
    t.string("name_lte")
    t.string("name_gt")
    t.string("name_gte")
    t.string("name_contains")
    t.string("name_not_contains")
    t.string("name_starts_with")
    t.string("name_not_starts_with")
    t.string("name_ends_with")
    t.string("name_not_ends_with")
    t.string("email")
    t.string("email_not")
    t.list.nonNull.string("email_in")
    t.list.nonNull.string("email_not_in")
    t.string("email_lt")
    t.string("email_lte")
    t.string("email_gt")
    t.string("email_gte")
    t.string("email_contains")
    t.string("email_not_contains")
    t.string("email_starts_with")
    t.string("email_not_starts_with")
    t.string("email_ends_with")
    t.string("email_not_ends_with")
    t.string("picture")
    t.string("picture_not")
    t.list.nonNull.string("picture_in")
    t.list.nonNull.string("picture_not_in")
    t.string("picture_lt")
    t.string("picture_lte")
    t.string("picture_gt")
    t.string("picture_gte")
    t.string("picture_contains")
    t.string("picture_not_contains")
    t.string("picture_starts_with")
    t.string("picture_not_starts_with")
    t.string("picture_ends_with")
    t.string("picture_not_ends_with")
    t.string("locale")
    t.string("locale_not")
    t.list.nonNull.string("locale_in")
    t.list.nonNull.string("locale_not_in")
    t.string("locale_lt")
    t.string("locale_lte")
    t.string("locale_gt")
    t.string("locale_gte")
    t.string("locale_contains")
    t.string("locale_not_contains")
    t.string("locale_starts_with")
    t.string("locale_not_starts_with")
    t.string("locale_ends_with")
    t.string("locale_not_ends_with")
    t.field("questions_every", { type: QuestionWhereInput })
    t.field("questions_some", { type: QuestionWhereInput })
    t.field("questions_none", { type: QuestionWhereInput })
    t.field("answers_every", { type: AnswerWhereInput })
    t.field("answers_some", { type: AnswerWhereInput })
    t.field("answers_none", { type: AnswerWhereInput })
    t.field("flags_every", { type: FlagWhereInput })
    t.field("flags_some", { type: FlagWhereInput })
    t.field("flags_none", { type: FlagWhereInput })
    t.field("tags_every", { type: TagWhereInput })
    t.field("tags_some", { type: TagWhereInput })
    t.field("tags_none", { type: TagWhereInput })
    t.field("specialties_every", { type: TagLabelWhereInput })
    t.field("specialties_some", { type: TagLabelWhereInput })
    t.field("specialties_none", { type: TagLabelWhereInput })
    t.field("history_every", { type: HistoryActionWhereInput })
    t.field("history_some", { type: HistoryActionWhereInput })
    t.field("history_none", { type: HistoryActionWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: UserWhereInput })
    t.list.nonNull.field("OR", { type: UserWhereInput })
    t.list.nonNull.field("NOT", { type: UserWhereInput })
  }
});
const UserWhereUniqueInput = inputObjectType({
  name: "UserWhereUniqueInput",
  definition(t) {
    t.id("id")
    t.string("auth0Id")
  }
});
const ZNodeCreateInput = inputObjectType({
  name: "ZNodeCreateInput",
  definition(t) {
    t.id("id")
    t.field("question", { type: QuestionCreateOneWithoutNodeInput })
    t.field("answer", { type: AnswerCreateOneWithoutNodeInput })
    t.field("flags", { type: FlagCreateManyWithoutNodeInput })
    t.field("tags", { type: TagCreateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeCreateOneWithoutAnswerInput = inputObjectType({
  name: "ZNodeCreateOneWithoutAnswerInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutAnswerInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeCreateOneWithoutFlagsInput = inputObjectType({
  name: "ZNodeCreateOneWithoutFlagsInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutFlagsInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeCreateOneWithoutHistoryInput = inputObjectType({
  name: "ZNodeCreateOneWithoutHistoryInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutHistoryInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeCreateOneWithoutQuestionInput = inputObjectType({
  name: "ZNodeCreateOneWithoutQuestionInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutQuestionInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeCreateOneWithoutTagsInput = inputObjectType({
  name: "ZNodeCreateOneWithoutTagsInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutTagsInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeCreateWithoutAnswerInput = inputObjectType({
  name: "ZNodeCreateWithoutAnswerInput",
  definition(t) {
    t.id("id")
    t.field("question", { type: QuestionCreateOneWithoutNodeInput })
    t.field("flags", { type: FlagCreateManyWithoutNodeInput })
    t.field("tags", { type: TagCreateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeCreateWithoutFlagsInput = inputObjectType({
  name: "ZNodeCreateWithoutFlagsInput",
  definition(t) {
    t.id("id")
    t.field("question", { type: QuestionCreateOneWithoutNodeInput })
    t.field("answer", { type: AnswerCreateOneWithoutNodeInput })
    t.field("tags", { type: TagCreateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeCreateWithoutHistoryInput = inputObjectType({
  name: "ZNodeCreateWithoutHistoryInput",
  definition(t) {
    t.id("id")
    t.field("question", { type: QuestionCreateOneWithoutNodeInput })
    t.field("answer", { type: AnswerCreateOneWithoutNodeInput })
    t.field("flags", { type: FlagCreateManyWithoutNodeInput })
    t.field("tags", { type: TagCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeCreateWithoutQuestionInput = inputObjectType({
  name: "ZNodeCreateWithoutQuestionInput",
  definition(t) {
    t.id("id")
    t.field("answer", { type: AnswerCreateOneWithoutNodeInput })
    t.field("flags", { type: FlagCreateManyWithoutNodeInput })
    t.field("tags", { type: TagCreateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeCreateWithoutTagsInput = inputObjectType({
  name: "ZNodeCreateWithoutTagsInput",
  definition(t) {
    t.id("id")
    t.field("question", { type: QuestionCreateOneWithoutNodeInput })
    t.field("answer", { type: AnswerCreateOneWithoutNodeInput })
    t.field("flags", { type: FlagCreateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionCreateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeSubscriptionWhereInput = inputObjectType({
  name: "ZNodeSubscriptionWhereInput",
  definition(t) {
    t.list.nonNull.field("mutation_in", { type: MutationType })
    t.string("updatedFields_contains")
    t.list.nonNull.string("updatedFields_contains_every")
    t.list.nonNull.string("updatedFields_contains_some")
    t.field("node", { type: ZNodeWhereInput })
    t.list.nonNull.field("AND", { type: ZNodeSubscriptionWhereInput })
    t.list.nonNull.field("OR", { type: ZNodeSubscriptionWhereInput })
    t.list.nonNull.field("NOT", { type: ZNodeSubscriptionWhereInput })
  }
});
const ZNodeUpdateInput = inputObjectType({
  name: "ZNodeUpdateInput",
  definition(t) {
    t.field("question", { type: QuestionUpdateOneWithoutNodeInput })
    t.field("answer", { type: AnswerUpdateOneWithoutNodeInput })
    t.field("flags", { type: FlagUpdateManyWithoutNodeInput })
    t.field("tags", { type: TagUpdateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateManyMutationInput = inputObjectType({
  name: "ZNodeUpdateManyMutationInput",
  definition(t) {
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateOneRequiredWithoutAnswerInput = inputObjectType({
  name: "ZNodeUpdateOneRequiredWithoutAnswerInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutAnswerInput })
    t.field("update", { type: ZNodeUpdateWithoutAnswerDataInput })
    t.field("upsert", { type: ZNodeUpsertWithoutAnswerInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeUpdateOneRequiredWithoutFlagsInput = inputObjectType({
  name: "ZNodeUpdateOneRequiredWithoutFlagsInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutFlagsInput })
    t.field("update", { type: ZNodeUpdateWithoutFlagsDataInput })
    t.field("upsert", { type: ZNodeUpsertWithoutFlagsInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeUpdateOneRequiredWithoutHistoryInput = inputObjectType({
  name: "ZNodeUpdateOneRequiredWithoutHistoryInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutHistoryInput })
    t.field("update", { type: ZNodeUpdateWithoutHistoryDataInput })
    t.field("upsert", { type: ZNodeUpsertWithoutHistoryInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeUpdateOneRequiredWithoutQuestionInput = inputObjectType({
  name: "ZNodeUpdateOneRequiredWithoutQuestionInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutQuestionInput })
    t.field("update", { type: ZNodeUpdateWithoutQuestionDataInput })
    t.field("upsert", { type: ZNodeUpsertWithoutQuestionInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeUpdateOneRequiredWithoutTagsInput = inputObjectType({
  name: "ZNodeUpdateOneRequiredWithoutTagsInput",
  definition(t) {
    t.field("create", { type: ZNodeCreateWithoutTagsInput })
    t.field("update", { type: ZNodeUpdateWithoutTagsDataInput })
    t.field("upsert", { type: ZNodeUpsertWithoutTagsInput })
    t.field("connect", { type: ZNodeWhereUniqueInput })
  }
});
const ZNodeUpdateWithoutAnswerDataInput = inputObjectType({
  name: "ZNodeUpdateWithoutAnswerDataInput",
  definition(t) {
    t.field("question", { type: QuestionUpdateOneWithoutNodeInput })
    t.field("flags", { type: FlagUpdateManyWithoutNodeInput })
    t.field("tags", { type: TagUpdateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateWithoutFlagsDataInput = inputObjectType({
  name: "ZNodeUpdateWithoutFlagsDataInput",
  definition(t) {
    t.field("question", { type: QuestionUpdateOneWithoutNodeInput })
    t.field("answer", { type: AnswerUpdateOneWithoutNodeInput })
    t.field("tags", { type: TagUpdateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateWithoutHistoryDataInput = inputObjectType({
  name: "ZNodeUpdateWithoutHistoryDataInput",
  definition(t) {
    t.field("question", { type: QuestionUpdateOneWithoutNodeInput })
    t.field("answer", { type: AnswerUpdateOneWithoutNodeInput })
    t.field("flags", { type: FlagUpdateManyWithoutNodeInput })
    t.field("tags", { type: TagUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateWithoutQuestionDataInput = inputObjectType({
  name: "ZNodeUpdateWithoutQuestionDataInput",
  definition(t) {
    t.field("answer", { type: AnswerUpdateOneWithoutNodeInput })
    t.field("flags", { type: FlagUpdateManyWithoutNodeInput })
    t.field("tags", { type: TagUpdateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpdateWithoutTagsDataInput = inputObjectType({
  name: "ZNodeUpdateWithoutTagsDataInput",
  definition(t) {
    t.field("question", { type: QuestionUpdateOneWithoutNodeInput })
    t.field("answer", { type: AnswerUpdateOneWithoutNodeInput })
    t.field("flags", { type: FlagUpdateManyWithoutNodeInput })
    t.field("history", { type: HistoryActionUpdateManyWithoutNodeInput })
    t.field("highlights", { type: Json })
  }
});
const ZNodeUpsertWithoutAnswerInput = inputObjectType({
  name: "ZNodeUpsertWithoutAnswerInput",
  definition(t) {
    t.nonNull.field("update", { type: ZNodeUpdateWithoutAnswerDataInput })
    t.nonNull.field("create", { type: ZNodeCreateWithoutAnswerInput })
  }
});
const ZNodeUpsertWithoutFlagsInput = inputObjectType({
  name: "ZNodeUpsertWithoutFlagsInput",
  definition(t) {
    t.nonNull.field("update", { type: ZNodeUpdateWithoutFlagsDataInput })
    t.nonNull.field("create", { type: ZNodeCreateWithoutFlagsInput })
  }
});
const ZNodeUpsertWithoutHistoryInput = inputObjectType({
  name: "ZNodeUpsertWithoutHistoryInput",
  definition(t) {
    t.nonNull.field("update", { type: ZNodeUpdateWithoutHistoryDataInput })
    t.nonNull.field("create", { type: ZNodeCreateWithoutHistoryInput })
  }
});
const ZNodeUpsertWithoutQuestionInput = inputObjectType({
  name: "ZNodeUpsertWithoutQuestionInput",
  definition(t) {
    t.nonNull.field("update", { type: ZNodeUpdateWithoutQuestionDataInput })
    t.nonNull.field("create", { type: ZNodeCreateWithoutQuestionInput })
  }
});
const ZNodeUpsertWithoutTagsInput = inputObjectType({
  name: "ZNodeUpsertWithoutTagsInput",
  definition(t) {
    t.nonNull.field("update", { type: ZNodeUpdateWithoutTagsDataInput })
    t.nonNull.field("create", { type: ZNodeCreateWithoutTagsInput })
  }
});
const ZNodeWhereInput = inputObjectType({
  name: "ZNodeWhereInput",
  definition(t) {
    t.id("id")
    t.id("id_not")
    t.list.nonNull.id("id_in")
    t.list.nonNull.id("id_not_in")
    t.id("id_lt")
    t.id("id_lte")
    t.id("id_gt")
    t.id("id_gte")
    t.id("id_contains")
    t.id("id_not_contains")
    t.id("id_starts_with")
    t.id("id_not_starts_with")
    t.id("id_ends_with")
    t.id("id_not_ends_with")
    t.field("question", { type: QuestionWhereInput })
    t.field("answer", { type: AnswerWhereInput })
    t.field("flags_every", { type: FlagWhereInput })
    t.field("flags_some", { type: FlagWhereInput })
    t.field("flags_none", { type: FlagWhereInput })
    t.field("tags_every", { type: TagWhereInput })
    t.field("tags_some", { type: TagWhereInput })
    t.field("tags_none", { type: TagWhereInput })
    t.field("history_every", { type: HistoryActionWhereInput })
    t.field("history_some", { type: HistoryActionWhereInput })
    t.field("history_none", { type: HistoryActionWhereInput })
    t.field("createdAt", { type: DateTime })
    t.field("createdAt_not", { type: DateTime })
    t.list.nonNull.field("createdAt_in", { type: DateTime })
    t.list.nonNull.field("createdAt_not_in", { type: DateTime })
    t.field("createdAt_lt", { type: DateTime })
    t.field("createdAt_lte", { type: DateTime })
    t.field("createdAt_gt", { type: DateTime })
    t.field("createdAt_gte", { type: DateTime })
    t.field("updatedAt", { type: DateTime })
    t.field("updatedAt_not", { type: DateTime })
    t.list.nonNull.field("updatedAt_in", { type: DateTime })
    t.list.nonNull.field("updatedAt_not_in", { type: DateTime })
    t.field("updatedAt_lt", { type: DateTime })
    t.field("updatedAt_lte", { type: DateTime })
    t.field("updatedAt_gt", { type: DateTime })
    t.field("updatedAt_gte", { type: DateTime })
    t.list.nonNull.field("AND", { type: ZNodeWhereInput })
    t.list.nonNull.field("OR", { type: ZNodeWhereInput })
    t.list.nonNull.field("NOT", { type: ZNodeWhereInput })
  }
});
const ZNodeWhereUniqueInput = inputObjectType({
  name: "ZNodeWhereUniqueInput",
  definition(t) {
    t.id("id")
  }
});

const AnswerOrderByInput = enumType({
  name: "AnswerOrderByInput",
  members: ['id_ASC','id_DESC','content_ASC','content_DESC','language_ASC','language_DESC','certified_ASC','certified_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const BugReporting = enumType({
  name: "BugReporting",
  members: ['MAIL','GITHUB'],
});
const ConfigurationOrderByInput = enumType({
  name: "ConfigurationOrderByInput",
  members: ['id_ASC','id_DESC','name_ASC','name_DESC','title_ASC','title_DESC','auth0Domain_ASC','auth0Domain_DESC','auth0ClientId_ASC','auth0ClientId_DESC','algoliaAppId_ASC','algoliaAppId_DESC','algoliaApiKey_ASC','algoliaApiKey_DESC','algoliaSynonyms_ASC','algoliaSynonyms_DESC','mailgunDomain_ASC','mailgunDomain_DESC','mailgunApiKey_ASC','mailgunApiKey_DESC','slackChannelHook_ASC','slackChannelHook_DESC','slackCommandKey_ASC','slackCommandKey_DESC','tags_ASC','tags_DESC','workplaceSharing_ASC','workplaceSharing_DESC','bugReporting_ASC','bugReporting_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const FlagOrderByInput = enumType({
  name: "FlagOrderByInput",
  members: ['id_ASC','id_DESC','type_ASC','type_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const HistoryActionOrderByInput = enumType({
  name: "HistoryActionOrderByInput",
  members: ['id_ASC','id_DESC','action_ASC','action_DESC','model_ASC','model_DESC','meta_ASC','meta_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const MutationType = enumType({
  name: "MutationType",
  members: ['CREATED','UPDATED','DELETED'],
});
const QuestionOrderByInput = enumType({
  name: "QuestionOrderByInput",
  members: ['id_ASC','id_DESC','title_ASC','title_DESC','language_ASC','language_DESC','slug_ASC','slug_DESC','views_ASC','views_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const SourceOrderByInput = enumType({
  name: "SourceOrderByInput",
  members: ['id_ASC','id_DESC','label_ASC','label_DESC','url_ASC','url_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const TagCategoryOrderByInput = enumType({
  name: "TagCategoryOrderByInput",
  members: ['id_ASC','id_DESC','name_ASC','name_DESC','order_ASC','order_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const TagLabelOrderByInput = enumType({
  name: "TagLabelOrderByInput",
  members: ['id_ASC','id_DESC','name_ASC','name_DESC','order_ASC','order_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const TagOrderByInput = enumType({
  name: "TagOrderByInput",
  members: ['id_ASC','id_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const TranslationOrderByInput = enumType({
  name: "TranslationOrderByInput",
  members: ['id_ASC','id_DESC','language_ASC','language_DESC','text_ASC','text_DESC'],
});
const UserOrderByInput = enumType({
  name: "UserOrderByInput",
  members: ['id_ASC','id_DESC','auth0Id_ASC','auth0Id_DESC','key_ASC','key_DESC','admin_ASC','admin_DESC','name_ASC','name_DESC','email_ASC','email_DESC','picture_ASC','picture_DESC','locale_ASC','locale_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});
const ZNodeOrderByInput = enumType({
  name: "ZNodeOrderByInput",
  members: ['id_ASC','id_DESC','highlights_ASC','highlights_DESC','createdAt_ASC','createdAt_DESC','updatedAt_ASC','updatedAt_DESC'],
});

const DateTime = scalarType({
  name: "DateTime",
  serialize() { /* Todo */ },
  parseValue() { /* Todo */ },
  parseLiteral() { /* Todo */ }
});
const Json = scalarType({
  name: "Json",
  serialize() { /* Todo */ },
  parseValue() { /* Todo */ },
  parseLiteral() { /* Todo */ }
});
const Long = scalarType({
  name: "Long",
  serialize() { /* Todo */ },
  parseValue() { /* Todo */ },
  parseLiteral() { /* Todo */ }
});