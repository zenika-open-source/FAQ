type AggregateAnswer {
  count: Int!
}

type AggregateConfiguration {
  count: Int!
}

type AggregateFlag {
  count: Int!
}

type AggregateHistoryAction {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateSource {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTagCategory {
  count: Int!
}

type AggregateTagLabel {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateZNode {
  count: Int!
}

type Answer {
  id: ID!
  content: String!
  sources(
    where: SourceWhereInput
    orderBy: SourceOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Source!]
  node: ZNode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  content: String!
  sources: SourceCreateManyWithoutAnswerInput
  node: ZNodeCreateOneWithoutAnswerInput!
  user: UserCreateOneWithoutAnswersInput!
}

input AnswerCreateManyWithoutUserInput {
  create: [AnswerCreateWithoutUserInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateOneWithoutNodeInput {
  create: AnswerCreateWithoutNodeInput
  connect: AnswerWhereUniqueInput
}

input AnswerCreateOneWithoutSourcesInput {
  create: AnswerCreateWithoutSourcesInput
  connect: AnswerWhereUniqueInput
}

input AnswerCreateWithoutNodeInput {
  id: ID
  content: String!
  sources: SourceCreateManyWithoutAnswerInput
  user: UserCreateOneWithoutAnswersInput!
}

input AnswerCreateWithoutSourcesInput {
  id: ID
  content: String!
  node: ZNodeCreateOneWithoutAnswerInput!
  user: UserCreateOneWithoutAnswersInput!
}

input AnswerCreateWithoutUserInput {
  id: ID
  content: String!
  sources: SourceCreateManyWithoutAnswerInput
  node: ZNodeCreateOneWithoutAnswerInput!
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AnswerPreviousValues {
  id: ID!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AnswerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateInput {
  content: String
  sources: SourceUpdateManyWithoutAnswerInput
  node: ZNodeUpdateOneRequiredWithoutAnswerInput
  user: UserUpdateOneRequiredWithoutAnswersInput
}

input AnswerUpdateManyDataInput {
  content: String
}

input AnswerUpdateManyMutationInput {
  content: String
}

input AnswerUpdateManyWithoutUserInput {
  create: [AnswerCreateWithoutUserInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerUpdateOneRequiredWithoutSourcesInput {
  create: AnswerCreateWithoutSourcesInput
  update: AnswerUpdateWithoutSourcesDataInput
  upsert: AnswerUpsertWithoutSourcesInput
  connect: AnswerWhereUniqueInput
}

input AnswerUpdateOneWithoutNodeInput {
  create: AnswerCreateWithoutNodeInput
  update: AnswerUpdateWithoutNodeDataInput
  upsert: AnswerUpsertWithoutNodeInput
  delete: Boolean
  disconnect: Boolean
  connect: AnswerWhereUniqueInput
}

input AnswerUpdateWithoutNodeDataInput {
  content: String
  sources: SourceUpdateManyWithoutAnswerInput
  user: UserUpdateOneRequiredWithoutAnswersInput
}

input AnswerUpdateWithoutSourcesDataInput {
  content: String
  node: ZNodeUpdateOneRequiredWithoutAnswerInput
  user: UserUpdateOneRequiredWithoutAnswersInput
}

input AnswerUpdateWithoutUserDataInput {
  content: String
  sources: SourceUpdateManyWithoutAnswerInput
  node: ZNodeUpdateOneRequiredWithoutAnswerInput
}

input AnswerUpdateWithWhereUniqueWithoutUserInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutUserDataInput!
}

input AnswerUpsertWithoutNodeInput {
  update: AnswerUpdateWithoutNodeDataInput!
  create: AnswerCreateWithoutNodeInput!
}

input AnswerUpsertWithoutSourcesInput {
  update: AnswerUpdateWithoutSourcesDataInput!
  create: AnswerCreateWithoutSourcesInput!
}

input AnswerUpsertWithWhereUniqueWithoutUserInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutUserDataInput!
  create: AnswerCreateWithoutUserInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  sources_every: SourceWhereInput
  sources_some: SourceWhereInput
  sources_none: SourceWhereInput
  node: ZNodeWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

enum BugReporting {
  MAIL
  GITHUB
}

type Configuration {
  id: ID!
  name: String!
  title: String!
  auth0Domain: String!
  auth0ClientId: String!
  authorizedDomains: [String!]!
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  tagCategories(
    where: TagCategoryWhereInput
    orderBy: TagCategoryOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [TagCategory!]
  workplaceSharing: Boolean
  bugReporting: BugReporting
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ConfigurationConnection {
  pageInfo: PageInfo!
  edges: [ConfigurationEdge]!
  aggregate: AggregateConfiguration!
}

input ConfigurationCreateauthorizedDomainsInput {
  set: [String!]
}

input ConfigurationCreateInput {
  id: ID
  name: String!
  title: String
  auth0Domain: String!
  auth0ClientId: String!
  authorizedDomains: ConfigurationCreateauthorizedDomainsInput
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  tagCategories: TagCategoryCreateManyWithoutConfigurationInput
  workplaceSharing: Boolean
  bugReporting: BugReporting
}

input ConfigurationCreateOneWithoutTagCategoriesInput {
  create: ConfigurationCreateWithoutTagCategoriesInput
  connect: ConfigurationWhereUniqueInput
}

input ConfigurationCreateWithoutTagCategoriesInput {
  id: ID
  name: String!
  title: String
  auth0Domain: String!
  auth0ClientId: String!
  authorizedDomains: ConfigurationCreateauthorizedDomainsInput
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  workplaceSharing: Boolean
  bugReporting: BugReporting
}

type ConfigurationEdge {
  node: Configuration!
  cursor: String!
}

enum ConfigurationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  auth0Domain_ASC
  auth0Domain_DESC
  auth0ClientId_ASC
  auth0ClientId_DESC
  algoliaAppId_ASC
  algoliaAppId_DESC
  algoliaApiKey_ASC
  algoliaApiKey_DESC
  algoliaSynonyms_ASC
  algoliaSynonyms_DESC
  mailgunDomain_ASC
  mailgunDomain_DESC
  mailgunApiKey_ASC
  mailgunApiKey_DESC
  slackChannelHook_ASC
  slackChannelHook_DESC
  slackCommandKey_ASC
  slackCommandKey_DESC
  tags_ASC
  tags_DESC
  workplaceSharing_ASC
  workplaceSharing_DESC
  bugReporting_ASC
  bugReporting_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConfigurationPreviousValues {
  id: ID!
  name: String!
  title: String!
  auth0Domain: String!
  auth0ClientId: String!
  authorizedDomains: [String!]!
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  workplaceSharing: Boolean
  bugReporting: BugReporting
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ConfigurationSubscriptionPayload {
  mutation: MutationType!
  node: Configuration
  updatedFields: [String!]
  previousValues: ConfigurationPreviousValues
}

input ConfigurationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConfigurationWhereInput
  AND: [ConfigurationSubscriptionWhereInput!]
  OR: [ConfigurationSubscriptionWhereInput!]
  NOT: [ConfigurationSubscriptionWhereInput!]
}

input ConfigurationUpdateauthorizedDomainsInput {
  set: [String!]
}

input ConfigurationUpdateInput {
  name: String
  title: String
  auth0Domain: String
  auth0ClientId: String
  authorizedDomains: ConfigurationUpdateauthorizedDomainsInput
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  tagCategories: TagCategoryUpdateManyWithoutConfigurationInput
  workplaceSharing: Boolean
  bugReporting: BugReporting
}

input ConfigurationUpdateManyMutationInput {
  name: String
  title: String
  auth0Domain: String
  auth0ClientId: String
  authorizedDomains: ConfigurationUpdateauthorizedDomainsInput
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  workplaceSharing: Boolean
  bugReporting: BugReporting
}

input ConfigurationUpdateOneRequiredWithoutTagCategoriesInput {
  create: ConfigurationCreateWithoutTagCategoriesInput
  update: ConfigurationUpdateWithoutTagCategoriesDataInput
  upsert: ConfigurationUpsertWithoutTagCategoriesInput
  connect: ConfigurationWhereUniqueInput
}

input ConfigurationUpdateWithoutTagCategoriesDataInput {
  name: String
  title: String
  auth0Domain: String
  auth0ClientId: String
  authorizedDomains: ConfigurationUpdateauthorizedDomainsInput
  algoliaAppId: String
  algoliaApiKey: String
  algoliaSynonyms: Json
  mailgunDomain: String
  mailgunApiKey: String
  slackChannelHook: String
  slackCommandKey: String
  tags: Json
  workplaceSharing: Boolean
  bugReporting: BugReporting
}

input ConfigurationUpsertWithoutTagCategoriesInput {
  update: ConfigurationUpdateWithoutTagCategoriesDataInput!
  create: ConfigurationCreateWithoutTagCategoriesInput!
}

input ConfigurationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  auth0Domain: String
  auth0Domain_not: String
  auth0Domain_in: [String!]
  auth0Domain_not_in: [String!]
  auth0Domain_lt: String
  auth0Domain_lte: String
  auth0Domain_gt: String
  auth0Domain_gte: String
  auth0Domain_contains: String
  auth0Domain_not_contains: String
  auth0Domain_starts_with: String
  auth0Domain_not_starts_with: String
  auth0Domain_ends_with: String
  auth0Domain_not_ends_with: String
  auth0ClientId: String
  auth0ClientId_not: String
  auth0ClientId_in: [String!]
  auth0ClientId_not_in: [String!]
  auth0ClientId_lt: String
  auth0ClientId_lte: String
  auth0ClientId_gt: String
  auth0ClientId_gte: String
  auth0ClientId_contains: String
  auth0ClientId_not_contains: String
  auth0ClientId_starts_with: String
  auth0ClientId_not_starts_with: String
  auth0ClientId_ends_with: String
  auth0ClientId_not_ends_with: String
  algoliaAppId: String
  algoliaAppId_not: String
  algoliaAppId_in: [String!]
  algoliaAppId_not_in: [String!]
  algoliaAppId_lt: String
  algoliaAppId_lte: String
  algoliaAppId_gt: String
  algoliaAppId_gte: String
  algoliaAppId_contains: String
  algoliaAppId_not_contains: String
  algoliaAppId_starts_with: String
  algoliaAppId_not_starts_with: String
  algoliaAppId_ends_with: String
  algoliaAppId_not_ends_with: String
  algoliaApiKey: String
  algoliaApiKey_not: String
  algoliaApiKey_in: [String!]
  algoliaApiKey_not_in: [String!]
  algoliaApiKey_lt: String
  algoliaApiKey_lte: String
  algoliaApiKey_gt: String
  algoliaApiKey_gte: String
  algoliaApiKey_contains: String
  algoliaApiKey_not_contains: String
  algoliaApiKey_starts_with: String
  algoliaApiKey_not_starts_with: String
  algoliaApiKey_ends_with: String
  algoliaApiKey_not_ends_with: String
  mailgunDomain: String
  mailgunDomain_not: String
  mailgunDomain_in: [String!]
  mailgunDomain_not_in: [String!]
  mailgunDomain_lt: String
  mailgunDomain_lte: String
  mailgunDomain_gt: String
  mailgunDomain_gte: String
  mailgunDomain_contains: String
  mailgunDomain_not_contains: String
  mailgunDomain_starts_with: String
  mailgunDomain_not_starts_with: String
  mailgunDomain_ends_with: String
  mailgunDomain_not_ends_with: String
  mailgunApiKey: String
  mailgunApiKey_not: String
  mailgunApiKey_in: [String!]
  mailgunApiKey_not_in: [String!]
  mailgunApiKey_lt: String
  mailgunApiKey_lte: String
  mailgunApiKey_gt: String
  mailgunApiKey_gte: String
  mailgunApiKey_contains: String
  mailgunApiKey_not_contains: String
  mailgunApiKey_starts_with: String
  mailgunApiKey_not_starts_with: String
  mailgunApiKey_ends_with: String
  mailgunApiKey_not_ends_with: String
  slackChannelHook: String
  slackChannelHook_not: String
  slackChannelHook_in: [String!]
  slackChannelHook_not_in: [String!]
  slackChannelHook_lt: String
  slackChannelHook_lte: String
  slackChannelHook_gt: String
  slackChannelHook_gte: String
  slackChannelHook_contains: String
  slackChannelHook_not_contains: String
  slackChannelHook_starts_with: String
  slackChannelHook_not_starts_with: String
  slackChannelHook_ends_with: String
  slackChannelHook_not_ends_with: String
  slackCommandKey: String
  slackCommandKey_not: String
  slackCommandKey_in: [String!]
  slackCommandKey_not_in: [String!]
  slackCommandKey_lt: String
  slackCommandKey_lte: String
  slackCommandKey_gt: String
  slackCommandKey_gte: String
  slackCommandKey_contains: String
  slackCommandKey_not_contains: String
  slackCommandKey_starts_with: String
  slackCommandKey_not_starts_with: String
  slackCommandKey_ends_with: String
  slackCommandKey_not_ends_with: String
  tagCategories_every: TagCategoryWhereInput
  tagCategories_some: TagCategoryWhereInput
  tagCategories_none: TagCategoryWhereInput
  workplaceSharing: Boolean
  workplaceSharing_not: Boolean
  bugReporting: BugReporting
  bugReporting_not: BugReporting
  bugReporting_in: [BugReporting!]
  bugReporting_not_in: [BugReporting!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ConfigurationWhereInput!]
  OR: [ConfigurationWhereInput!]
  NOT: [ConfigurationWhereInput!]
}

input ConfigurationWhereUniqueInput {
  id: ID
  name: String
}

scalar DateTime

type Flag {
  id: ID!
  type: String!
  node: ZNode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FlagConnection {
  pageInfo: PageInfo!
  edges: [FlagEdge]!
  aggregate: AggregateFlag!
}

input FlagCreateInput {
  id: ID
  type: String!
  node: ZNodeCreateOneWithoutFlagsInput!
  user: UserCreateOneWithoutFlagsInput!
}

input FlagCreateManyWithoutNodeInput {
  create: [FlagCreateWithoutNodeInput!]
  connect: [FlagWhereUniqueInput!]
}

input FlagCreateManyWithoutUserInput {
  create: [FlagCreateWithoutUserInput!]
  connect: [FlagWhereUniqueInput!]
}

input FlagCreateWithoutNodeInput {
  id: ID
  type: String!
  user: UserCreateOneWithoutFlagsInput!
}

input FlagCreateWithoutUserInput {
  id: ID
  type: String!
  node: ZNodeCreateOneWithoutFlagsInput!
}

type FlagEdge {
  node: Flag!
  cursor: String!
}

enum FlagOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FlagPreviousValues {
  id: ID!
  type: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FlagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FlagScalarWhereInput!]
  OR: [FlagScalarWhereInput!]
  NOT: [FlagScalarWhereInput!]
}

type FlagSubscriptionPayload {
  mutation: MutationType!
  node: Flag
  updatedFields: [String!]
  previousValues: FlagPreviousValues
}

input FlagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FlagWhereInput
  AND: [FlagSubscriptionWhereInput!]
  OR: [FlagSubscriptionWhereInput!]
  NOT: [FlagSubscriptionWhereInput!]
}

input FlagUpdateInput {
  type: String
  node: ZNodeUpdateOneRequiredWithoutFlagsInput
  user: UserUpdateOneRequiredWithoutFlagsInput
}

input FlagUpdateManyDataInput {
  type: String
}

input FlagUpdateManyMutationInput {
  type: String
}

input FlagUpdateManyWithoutNodeInput {
  create: [FlagCreateWithoutNodeInput!]
  delete: [FlagWhereUniqueInput!]
  connect: [FlagWhereUniqueInput!]
  set: [FlagWhereUniqueInput!]
  disconnect: [FlagWhereUniqueInput!]
  update: [FlagUpdateWithWhereUniqueWithoutNodeInput!]
  upsert: [FlagUpsertWithWhereUniqueWithoutNodeInput!]
  deleteMany: [FlagScalarWhereInput!]
  updateMany: [FlagUpdateManyWithWhereNestedInput!]
}

input FlagUpdateManyWithoutUserInput {
  create: [FlagCreateWithoutUserInput!]
  delete: [FlagWhereUniqueInput!]
  connect: [FlagWhereUniqueInput!]
  set: [FlagWhereUniqueInput!]
  disconnect: [FlagWhereUniqueInput!]
  update: [FlagUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [FlagUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [FlagScalarWhereInput!]
  updateMany: [FlagUpdateManyWithWhereNestedInput!]
}

input FlagUpdateManyWithWhereNestedInput {
  where: FlagScalarWhereInput!
  data: FlagUpdateManyDataInput!
}

input FlagUpdateWithoutNodeDataInput {
  type: String
  user: UserUpdateOneRequiredWithoutFlagsInput
}

input FlagUpdateWithoutUserDataInput {
  type: String
  node: ZNodeUpdateOneRequiredWithoutFlagsInput
}

input FlagUpdateWithWhereUniqueWithoutNodeInput {
  where: FlagWhereUniqueInput!
  data: FlagUpdateWithoutNodeDataInput!
}

input FlagUpdateWithWhereUniqueWithoutUserInput {
  where: FlagWhereUniqueInput!
  data: FlagUpdateWithoutUserDataInput!
}

input FlagUpsertWithWhereUniqueWithoutNodeInput {
  where: FlagWhereUniqueInput!
  update: FlagUpdateWithoutNodeDataInput!
  create: FlagCreateWithoutNodeInput!
}

input FlagUpsertWithWhereUniqueWithoutUserInput {
  where: FlagWhereUniqueInput!
  update: FlagUpdateWithoutUserDataInput!
  create: FlagCreateWithoutUserInput!
}

input FlagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  node: ZNodeWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FlagWhereInput!]
  OR: [FlagWhereInput!]
  NOT: [FlagWhereInput!]
}

input FlagWhereUniqueInput {
  id: ID
}

type HistoryAction {
  id: ID!
  action: String!
  model: String!
  meta: Json
  node: ZNode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HistoryActionConnection {
  pageInfo: PageInfo!
  edges: [HistoryActionEdge]!
  aggregate: AggregateHistoryAction!
}

input HistoryActionCreateInput {
  id: ID
  action: String!
  model: String!
  meta: Json
  node: ZNodeCreateOneWithoutHistoryInput!
  user: UserCreateOneWithoutHistoryInput!
}

input HistoryActionCreateManyWithoutNodeInput {
  create: [HistoryActionCreateWithoutNodeInput!]
  connect: [HistoryActionWhereUniqueInput!]
}

input HistoryActionCreateManyWithoutUserInput {
  create: [HistoryActionCreateWithoutUserInput!]
  connect: [HistoryActionWhereUniqueInput!]
}

input HistoryActionCreateWithoutNodeInput {
  id: ID
  action: String!
  model: String!
  meta: Json
  user: UserCreateOneWithoutHistoryInput!
}

input HistoryActionCreateWithoutUserInput {
  id: ID
  action: String!
  model: String!
  meta: Json
  node: ZNodeCreateOneWithoutHistoryInput!
}

type HistoryActionEdge {
  node: HistoryAction!
  cursor: String!
}

enum HistoryActionOrderByInput {
  id_ASC
  id_DESC
  action_ASC
  action_DESC
  model_ASC
  model_DESC
  meta_ASC
  meta_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HistoryActionPreviousValues {
  id: ID!
  action: String!
  model: String!
  meta: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HistoryActionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  action: String
  action_not: String
  action_in: [String!]
  action_not_in: [String!]
  action_lt: String
  action_lte: String
  action_gt: String
  action_gte: String
  action_contains: String
  action_not_contains: String
  action_starts_with: String
  action_not_starts_with: String
  action_ends_with: String
  action_not_ends_with: String
  model: String
  model_not: String
  model_in: [String!]
  model_not_in: [String!]
  model_lt: String
  model_lte: String
  model_gt: String
  model_gte: String
  model_contains: String
  model_not_contains: String
  model_starts_with: String
  model_not_starts_with: String
  model_ends_with: String
  model_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HistoryActionScalarWhereInput!]
  OR: [HistoryActionScalarWhereInput!]
  NOT: [HistoryActionScalarWhereInput!]
}

type HistoryActionSubscriptionPayload {
  mutation: MutationType!
  node: HistoryAction
  updatedFields: [String!]
  previousValues: HistoryActionPreviousValues
}

input HistoryActionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HistoryActionWhereInput
  AND: [HistoryActionSubscriptionWhereInput!]
  OR: [HistoryActionSubscriptionWhereInput!]
  NOT: [HistoryActionSubscriptionWhereInput!]
}

input HistoryActionUpdateInput {
  action: String
  model: String
  meta: Json
  node: ZNodeUpdateOneRequiredWithoutHistoryInput
  user: UserUpdateOneRequiredWithoutHistoryInput
}

input HistoryActionUpdateManyDataInput {
  action: String
  model: String
  meta: Json
}

input HistoryActionUpdateManyMutationInput {
  action: String
  model: String
  meta: Json
}

input HistoryActionUpdateManyWithoutNodeInput {
  create: [HistoryActionCreateWithoutNodeInput!]
  delete: [HistoryActionWhereUniqueInput!]
  connect: [HistoryActionWhereUniqueInput!]
  set: [HistoryActionWhereUniqueInput!]
  disconnect: [HistoryActionWhereUniqueInput!]
  update: [HistoryActionUpdateWithWhereUniqueWithoutNodeInput!]
  upsert: [HistoryActionUpsertWithWhereUniqueWithoutNodeInput!]
  deleteMany: [HistoryActionScalarWhereInput!]
  updateMany: [HistoryActionUpdateManyWithWhereNestedInput!]
}

input HistoryActionUpdateManyWithoutUserInput {
  create: [HistoryActionCreateWithoutUserInput!]
  delete: [HistoryActionWhereUniqueInput!]
  connect: [HistoryActionWhereUniqueInput!]
  set: [HistoryActionWhereUniqueInput!]
  disconnect: [HistoryActionWhereUniqueInput!]
  update: [HistoryActionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [HistoryActionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [HistoryActionScalarWhereInput!]
  updateMany: [HistoryActionUpdateManyWithWhereNestedInput!]
}

input HistoryActionUpdateManyWithWhereNestedInput {
  where: HistoryActionScalarWhereInput!
  data: HistoryActionUpdateManyDataInput!
}

input HistoryActionUpdateWithoutNodeDataInput {
  action: String
  model: String
  meta: Json
  user: UserUpdateOneRequiredWithoutHistoryInput
}

input HistoryActionUpdateWithoutUserDataInput {
  action: String
  model: String
  meta: Json
  node: ZNodeUpdateOneRequiredWithoutHistoryInput
}

input HistoryActionUpdateWithWhereUniqueWithoutNodeInput {
  where: HistoryActionWhereUniqueInput!
  data: HistoryActionUpdateWithoutNodeDataInput!
}

input HistoryActionUpdateWithWhereUniqueWithoutUserInput {
  where: HistoryActionWhereUniqueInput!
  data: HistoryActionUpdateWithoutUserDataInput!
}

input HistoryActionUpsertWithWhereUniqueWithoutNodeInput {
  where: HistoryActionWhereUniqueInput!
  update: HistoryActionUpdateWithoutNodeDataInput!
  create: HistoryActionCreateWithoutNodeInput!
}

input HistoryActionUpsertWithWhereUniqueWithoutUserInput {
  where: HistoryActionWhereUniqueInput!
  update: HistoryActionUpdateWithoutUserDataInput!
  create: HistoryActionCreateWithoutUserInput!
}

input HistoryActionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  action: String
  action_not: String
  action_in: [String!]
  action_not_in: [String!]
  action_lt: String
  action_lte: String
  action_gt: String
  action_gte: String
  action_contains: String
  action_not_contains: String
  action_starts_with: String
  action_not_starts_with: String
  action_ends_with: String
  action_not_ends_with: String
  model: String
  model_not: String
  model_in: [String!]
  model_not_in: [String!]
  model_lt: String
  model_lte: String
  model_gt: String
  model_gte: String
  model_contains: String
  model_not_contains: String
  model_starts_with: String
  model_not_starts_with: String
  model_ends_with: String
  model_not_ends_with: String
  node: ZNodeWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HistoryActionWhereInput!]
  OR: [HistoryActionWhereInput!]
  NOT: [HistoryActionWhereInput!]
}

input HistoryActionWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Mutation {
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(
    where: AnswerWhereUniqueInput!
    create: AnswerCreateInput!
    update: AnswerUpdateInput!
  ): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createConfiguration(data: ConfigurationCreateInput!): Configuration!
  updateConfiguration(
    data: ConfigurationUpdateInput!
    where: ConfigurationWhereUniqueInput!
  ): Configuration
  updateManyConfigurations(
    data: ConfigurationUpdateManyMutationInput!
    where: ConfigurationWhereInput
  ): BatchPayload!
  upsertConfiguration(
    where: ConfigurationWhereUniqueInput!
    create: ConfigurationCreateInput!
    update: ConfigurationUpdateInput!
  ): Configuration!
  deleteConfiguration(where: ConfigurationWhereUniqueInput!): Configuration
  deleteManyConfigurations(where: ConfigurationWhereInput): BatchPayload!
  createFlag(data: FlagCreateInput!): Flag!
  updateFlag(data: FlagUpdateInput!, where: FlagWhereUniqueInput!): Flag
  updateManyFlags(data: FlagUpdateManyMutationInput!, where: FlagWhereInput): BatchPayload!
  upsertFlag(
    where: FlagWhereUniqueInput!
    create: FlagCreateInput!
    update: FlagUpdateInput!
  ): Flag!
  deleteFlag(where: FlagWhereUniqueInput!): Flag
  deleteManyFlags(where: FlagWhereInput): BatchPayload!
  createHistoryAction(data: HistoryActionCreateInput!): HistoryAction!
  updateHistoryAction(
    data: HistoryActionUpdateInput!
    where: HistoryActionWhereUniqueInput!
  ): HistoryAction
  updateManyHistoryActions(
    data: HistoryActionUpdateManyMutationInput!
    where: HistoryActionWhereInput
  ): BatchPayload!
  upsertHistoryAction(
    where: HistoryActionWhereUniqueInput!
    create: HistoryActionCreateInput!
    update: HistoryActionUpdateInput!
  ): HistoryAction!
  deleteHistoryAction(where: HistoryActionWhereUniqueInput!): HistoryAction
  deleteManyHistoryActions(where: HistoryActionWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(
    data: QuestionUpdateManyMutationInput!
    where: QuestionWhereInput
  ): BatchPayload!
  upsertQuestion(
    where: QuestionWhereUniqueInput!
    create: QuestionCreateInput!
    update: QuestionUpdateInput!
  ): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createSource(data: SourceCreateInput!): Source!
  updateSource(data: SourceUpdateInput!, where: SourceWhereUniqueInput!): Source
  updateManySources(data: SourceUpdateManyMutationInput!, where: SourceWhereInput): BatchPayload!
  upsertSource(
    where: SourceWhereUniqueInput!
    create: SourceCreateInput!
    update: SourceUpdateInput!
  ): Source!
  deleteSource(where: SourceWhereUniqueInput!): Source
  deleteManySources(where: SourceWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createTagCategory(data: TagCategoryCreateInput!): TagCategory!
  updateTagCategory(data: TagCategoryUpdateInput!, where: TagCategoryWhereUniqueInput!): TagCategory
  updateManyTagCategories(
    data: TagCategoryUpdateManyMutationInput!
    where: TagCategoryWhereInput
  ): BatchPayload!
  upsertTagCategory(
    where: TagCategoryWhereUniqueInput!
    create: TagCategoryCreateInput!
    update: TagCategoryUpdateInput!
  ): TagCategory!
  deleteTagCategory(where: TagCategoryWhereUniqueInput!): TagCategory
  deleteManyTagCategories(where: TagCategoryWhereInput): BatchPayload!
  createTagLabel(data: TagLabelCreateInput!): TagLabel!
  updateTagLabel(data: TagLabelUpdateInput!, where: TagLabelWhereUniqueInput!): TagLabel
  updateManyTagLabels(
    data: TagLabelUpdateManyMutationInput!
    where: TagLabelWhereInput
  ): BatchPayload!
  upsertTagLabel(
    where: TagLabelWhereUniqueInput!
    create: TagLabelCreateInput!
    update: TagLabelUpdateInput!
  ): TagLabel!
  deleteTagLabel(where: TagLabelWhereUniqueInput!): TagLabel
  deleteManyTagLabels(where: TagLabelWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(
    where: UserWhereUniqueInput!
    create: UserCreateInput!
    update: UserUpdateInput!
  ): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createZNode(data: ZNodeCreateInput!): ZNode!
  updateZNode(data: ZNodeUpdateInput!, where: ZNodeWhereUniqueInput!): ZNode
  updateManyZNodes(data: ZNodeUpdateManyMutationInput!, where: ZNodeWhereInput): BatchPayload!
  upsertZNode(
    where: ZNodeWhereUniqueInput!
    create: ZNodeCreateInput!
    update: ZNodeUpdateInput!
  ): ZNode!
  deleteZNode(where: ZNodeWhereUniqueInput!): ZNode
  deleteManyZNodes(where: ZNodeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(
    where: AnswerWhereInput
    orderBy: AnswerOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Answer]!
  answersConnection(
    where: AnswerWhereInput
    orderBy: AnswerOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): AnswerConnection!
  configuration(where: ConfigurationWhereUniqueInput!): Configuration
  configurations(
    where: ConfigurationWhereInput
    orderBy: ConfigurationOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Configuration]!
  configurationsConnection(
    where: ConfigurationWhereInput
    orderBy: ConfigurationOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): ConfigurationConnection!
  flag(where: FlagWhereUniqueInput!): Flag
  flags(
    where: FlagWhereInput
    orderBy: FlagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Flag]!
  flagsConnection(
    where: FlagWhereInput
    orderBy: FlagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): FlagConnection!
  historyAction(where: HistoryActionWhereUniqueInput!): HistoryAction
  historyActions(
    where: HistoryActionWhereInput
    orderBy: HistoryActionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [HistoryAction]!
  historyActionsConnection(
    where: HistoryActionWhereInput
    orderBy: HistoryActionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): HistoryActionConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(
    where: QuestionWhereInput
    orderBy: QuestionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Question]!
  questionsConnection(
    where: QuestionWhereInput
    orderBy: QuestionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): QuestionConnection!
  source(where: SourceWhereUniqueInput!): Source
  sources(
    where: SourceWhereInput
    orderBy: SourceOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Source]!
  sourcesConnection(
    where: SourceWhereInput
    orderBy: SourceOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): SourceConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(
    where: TagWhereInput
    orderBy: TagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Tag]!
  tagsConnection(
    where: TagWhereInput
    orderBy: TagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): TagConnection!
  tagCategory(where: TagCategoryWhereUniqueInput!): TagCategory
  tagCategories(
    where: TagCategoryWhereInput
    orderBy: TagCategoryOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [TagCategory]!
  tagCategoriesConnection(
    where: TagCategoryWhereInput
    orderBy: TagCategoryOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): TagCategoryConnection!
  tagLabel(where: TagLabelWhereUniqueInput!): TagLabel
  tagLabels(
    where: TagLabelWhereInput
    orderBy: TagLabelOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [TagLabel]!
  tagLabelsConnection(
    where: TagLabelWhereInput
    orderBy: TagLabelOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): TagLabelConnection!
  user(where: UserWhereUniqueInput!): User
  users(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [User]!
  usersConnection(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  zNode(where: ZNodeWhereUniqueInput!): ZNode
  zNodes(
    where: ZNodeWhereInput
    orderBy: ZNodeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [ZNode]!
  zNodesConnection(
    where: ZNodeWhereInput
    orderBy: ZNodeOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): ZNodeConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  title: String!
  slug: String!
  views: Int
  node: ZNode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  title: String!
  slug: String!
  views: Int
  node: ZNodeCreateOneWithoutQuestionInput!
  user: UserCreateOneWithoutQuestionsInput!
}

input QuestionCreateManyWithoutUserInput {
  create: [QuestionCreateWithoutUserInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateOneWithoutNodeInput {
  create: QuestionCreateWithoutNodeInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateWithoutNodeInput {
  id: ID
  title: String!
  slug: String!
  views: Int
  user: UserCreateOneWithoutQuestionsInput!
}

input QuestionCreateWithoutUserInput {
  id: ID
  title: String!
  slug: String!
  views: Int
  node: ZNodeCreateOneWithoutQuestionInput!
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
  views_ASC
  views_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuestionPreviousValues {
  id: ID!
  title: String!
  slug: String!
  views: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  views: Int
  views_not: Int
  views_in: [Int!]
  views_not_in: [Int!]
  views_lt: Int
  views_lte: Int
  views_gt: Int
  views_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateInput {
  title: String
  slug: String
  views: Int
  node: ZNodeUpdateOneRequiredWithoutQuestionInput
  user: UserUpdateOneRequiredWithoutQuestionsInput
}

input QuestionUpdateManyDataInput {
  title: String
  slug: String
  views: Int
}

input QuestionUpdateManyMutationInput {
  title: String
  slug: String
  views: Int
}

input QuestionUpdateManyWithoutUserInput {
  create: [QuestionCreateWithoutUserInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateOneWithoutNodeInput {
  create: QuestionCreateWithoutNodeInput
  update: QuestionUpdateWithoutNodeDataInput
  upsert: QuestionUpsertWithoutNodeInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionWhereUniqueInput
}

input QuestionUpdateWithoutNodeDataInput {
  title: String
  slug: String
  views: Int
  user: UserUpdateOneRequiredWithoutQuestionsInput
}

input QuestionUpdateWithoutUserDataInput {
  title: String
  slug: String
  views: Int
  node: ZNodeUpdateOneRequiredWithoutQuestionInput
}

input QuestionUpdateWithWhereUniqueWithoutUserInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutUserDataInput!
}

input QuestionUpsertWithoutNodeInput {
  update: QuestionUpdateWithoutNodeDataInput!
  create: QuestionCreateWithoutNodeInput!
}

input QuestionUpsertWithWhereUniqueWithoutUserInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutUserDataInput!
  create: QuestionCreateWithoutUserInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  views: Int
  views_not: Int
  views_in: [Int!]
  views_not_in: [Int!]
  views_lt: Int
  views_lte: Int
  views_gt: Int
  views_gte: Int
  node: ZNodeWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

type Source {
  id: ID!
  label: String!
  url: String!
  answer: Answer!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SourceConnection {
  pageInfo: PageInfo!
  edges: [SourceEdge]!
  aggregate: AggregateSource!
}

input SourceCreateInput {
  id: ID
  label: String!
  url: String!
  answer: AnswerCreateOneWithoutSourcesInput!
}

input SourceCreateManyWithoutAnswerInput {
  create: [SourceCreateWithoutAnswerInput!]
  connect: [SourceWhereUniqueInput!]
}

input SourceCreateWithoutAnswerInput {
  id: ID
  label: String!
  url: String!
}

type SourceEdge {
  node: Source!
  cursor: String!
}

enum SourceOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SourcePreviousValues {
  id: ID!
  label: String!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SourceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SourceScalarWhereInput!]
  OR: [SourceScalarWhereInput!]
  NOT: [SourceScalarWhereInput!]
}

type SourceSubscriptionPayload {
  mutation: MutationType!
  node: Source
  updatedFields: [String!]
  previousValues: SourcePreviousValues
}

input SourceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SourceWhereInput
  AND: [SourceSubscriptionWhereInput!]
  OR: [SourceSubscriptionWhereInput!]
  NOT: [SourceSubscriptionWhereInput!]
}

input SourceUpdateInput {
  label: String
  url: String
  answer: AnswerUpdateOneRequiredWithoutSourcesInput
}

input SourceUpdateManyDataInput {
  label: String
  url: String
}

input SourceUpdateManyMutationInput {
  label: String
  url: String
}

input SourceUpdateManyWithoutAnswerInput {
  create: [SourceCreateWithoutAnswerInput!]
  delete: [SourceWhereUniqueInput!]
  connect: [SourceWhereUniqueInput!]
  set: [SourceWhereUniqueInput!]
  disconnect: [SourceWhereUniqueInput!]
  update: [SourceUpdateWithWhereUniqueWithoutAnswerInput!]
  upsert: [SourceUpsertWithWhereUniqueWithoutAnswerInput!]
  deleteMany: [SourceScalarWhereInput!]
  updateMany: [SourceUpdateManyWithWhereNestedInput!]
}

input SourceUpdateManyWithWhereNestedInput {
  where: SourceScalarWhereInput!
  data: SourceUpdateManyDataInput!
}

input SourceUpdateWithoutAnswerDataInput {
  label: String
  url: String
}

input SourceUpdateWithWhereUniqueWithoutAnswerInput {
  where: SourceWhereUniqueInput!
  data: SourceUpdateWithoutAnswerDataInput!
}

input SourceUpsertWithWhereUniqueWithoutAnswerInput {
  where: SourceWhereUniqueInput!
  update: SourceUpdateWithoutAnswerDataInput!
  create: SourceCreateWithoutAnswerInput!
}

input SourceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  answer: AnswerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SourceWhereInput!]
  OR: [SourceWhereInput!]
  NOT: [SourceWhereInput!]
}

input SourceWhereUniqueInput {
  id: ID
}

type Subscription {
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  configuration(where: ConfigurationSubscriptionWhereInput): ConfigurationSubscriptionPayload
  flag(where: FlagSubscriptionWhereInput): FlagSubscriptionPayload
  historyAction(where: HistoryActionSubscriptionWhereInput): HistoryActionSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  source(where: SourceSubscriptionWhereInput): SourceSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  tagCategory(where: TagCategorySubscriptionWhereInput): TagCategorySubscriptionPayload
  tagLabel(where: TagLabelSubscriptionWhereInput): TagLabelSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  zNode(where: ZNodeSubscriptionWhereInput): ZNodeSubscriptionPayload
}

type Tag {
  id: ID!
  label: TagLabel
  node: ZNode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TagCategory {
  id: ID!
  name: String!
  labels(
    where: TagLabelWhereInput
    orderBy: TagLabelOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [TagLabel!]
  order: Int!
  configuration: Configuration!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TagCategoryConnection {
  pageInfo: PageInfo!
  edges: [TagCategoryEdge]!
  aggregate: AggregateTagCategory!
}

input TagCategoryCreateInput {
  id: ID
  name: String!
  labels: TagLabelCreateManyWithoutCategoryInput
  order: Int!
  configuration: ConfigurationCreateOneWithoutTagCategoriesInput!
}

input TagCategoryCreateManyWithoutConfigurationInput {
  create: [TagCategoryCreateWithoutConfigurationInput!]
  connect: [TagCategoryWhereUniqueInput!]
}

input TagCategoryCreateOneWithoutLabelsInput {
  create: TagCategoryCreateWithoutLabelsInput
  connect: TagCategoryWhereUniqueInput
}

input TagCategoryCreateWithoutConfigurationInput {
  id: ID
  name: String!
  labels: TagLabelCreateManyWithoutCategoryInput
  order: Int!
}

input TagCategoryCreateWithoutLabelsInput {
  id: ID
  name: String!
  order: Int!
  configuration: ConfigurationCreateOneWithoutTagCategoriesInput!
}

type TagCategoryEdge {
  node: TagCategory!
  cursor: String!
}

enum TagCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagCategoryPreviousValues {
  id: ID!
  name: String!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TagCategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagCategoryScalarWhereInput!]
  OR: [TagCategoryScalarWhereInput!]
  NOT: [TagCategoryScalarWhereInput!]
}

type TagCategorySubscriptionPayload {
  mutation: MutationType!
  node: TagCategory
  updatedFields: [String!]
  previousValues: TagCategoryPreviousValues
}

input TagCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagCategoryWhereInput
  AND: [TagCategorySubscriptionWhereInput!]
  OR: [TagCategorySubscriptionWhereInput!]
  NOT: [TagCategorySubscriptionWhereInput!]
}

input TagCategoryUpdateInput {
  name: String
  labels: TagLabelUpdateManyWithoutCategoryInput
  order: Int
  configuration: ConfigurationUpdateOneRequiredWithoutTagCategoriesInput
}

input TagCategoryUpdateManyDataInput {
  name: String
  order: Int
}

input TagCategoryUpdateManyMutationInput {
  name: String
  order: Int
}

input TagCategoryUpdateManyWithoutConfigurationInput {
  create: [TagCategoryCreateWithoutConfigurationInput!]
  delete: [TagCategoryWhereUniqueInput!]
  connect: [TagCategoryWhereUniqueInput!]
  set: [TagCategoryWhereUniqueInput!]
  disconnect: [TagCategoryWhereUniqueInput!]
  update: [TagCategoryUpdateWithWhereUniqueWithoutConfigurationInput!]
  upsert: [TagCategoryUpsertWithWhereUniqueWithoutConfigurationInput!]
  deleteMany: [TagCategoryScalarWhereInput!]
  updateMany: [TagCategoryUpdateManyWithWhereNestedInput!]
}

input TagCategoryUpdateManyWithWhereNestedInput {
  where: TagCategoryScalarWhereInput!
  data: TagCategoryUpdateManyDataInput!
}

input TagCategoryUpdateOneRequiredWithoutLabelsInput {
  create: TagCategoryCreateWithoutLabelsInput
  update: TagCategoryUpdateWithoutLabelsDataInput
  upsert: TagCategoryUpsertWithoutLabelsInput
  connect: TagCategoryWhereUniqueInput
}

input TagCategoryUpdateWithoutConfigurationDataInput {
  name: String
  labels: TagLabelUpdateManyWithoutCategoryInput
  order: Int
}

input TagCategoryUpdateWithoutLabelsDataInput {
  name: String
  order: Int
  configuration: ConfigurationUpdateOneRequiredWithoutTagCategoriesInput
}

input TagCategoryUpdateWithWhereUniqueWithoutConfigurationInput {
  where: TagCategoryWhereUniqueInput!
  data: TagCategoryUpdateWithoutConfigurationDataInput!
}

input TagCategoryUpsertWithoutLabelsInput {
  update: TagCategoryUpdateWithoutLabelsDataInput!
  create: TagCategoryCreateWithoutLabelsInput!
}

input TagCategoryUpsertWithWhereUniqueWithoutConfigurationInput {
  where: TagCategoryWhereUniqueInput!
  update: TagCategoryUpdateWithoutConfigurationDataInput!
  create: TagCategoryCreateWithoutConfigurationInput!
}

input TagCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  labels_every: TagLabelWhereInput
  labels_some: TagLabelWhereInput
  labels_none: TagLabelWhereInput
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  configuration: ConfigurationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagCategoryWhereInput!]
  OR: [TagCategoryWhereInput!]
  NOT: [TagCategoryWhereInput!]
}

input TagCategoryWhereUniqueInput {
  id: ID
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  label: TagLabelCreateOneWithoutTagsInput
  node: ZNodeCreateOneWithoutTagsInput!
  user: UserCreateOneWithoutTagsInput!
}

input TagCreateManyWithoutLabelInput {
  create: [TagCreateWithoutLabelInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateManyWithoutNodeInput {
  create: [TagCreateWithoutNodeInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateWithoutLabelInput {
  id: ID
  node: ZNodeCreateOneWithoutTagsInput!
  user: UserCreateOneWithoutTagsInput!
}

input TagCreateWithoutNodeInput {
  id: ID
  label: TagLabelCreateOneWithoutTagsInput
  user: UserCreateOneWithoutTagsInput!
}

input TagCreateWithoutUserInput {
  id: ID
  label: TagLabelCreateOneWithoutTagsInput
  node: ZNodeCreateOneWithoutTagsInput!
}

type TagEdge {
  node: Tag!
  cursor: String!
}

type TagLabel {
  id: ID!
  name: String!
  tags(
    where: TagWhereInput
    orderBy: TagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Tag!]
  order: Int!
  category: TagCategory!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TagLabelConnection {
  pageInfo: PageInfo!
  edges: [TagLabelEdge]!
  aggregate: AggregateTagLabel!
}

input TagLabelCreateInput {
  id: ID
  name: String!
  tags: TagCreateManyWithoutLabelInput
  order: Int!
  category: TagCategoryCreateOneWithoutLabelsInput!
}

input TagLabelCreateManyWithoutCategoryInput {
  create: [TagLabelCreateWithoutCategoryInput!]
  connect: [TagLabelWhereUniqueInput!]
}

input TagLabelCreateOneWithoutTagsInput {
  create: TagLabelCreateWithoutTagsInput
  connect: TagLabelWhereUniqueInput
}

input TagLabelCreateWithoutCategoryInput {
  id: ID
  name: String!
  tags: TagCreateManyWithoutLabelInput
  order: Int!
}

input TagLabelCreateWithoutTagsInput {
  id: ID
  name: String!
  order: Int!
  category: TagCategoryCreateOneWithoutLabelsInput!
}

type TagLabelEdge {
  node: TagLabel!
  cursor: String!
}

enum TagLabelOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagLabelPreviousValues {
  id: ID!
  name: String!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TagLabelScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagLabelScalarWhereInput!]
  OR: [TagLabelScalarWhereInput!]
  NOT: [TagLabelScalarWhereInput!]
}

type TagLabelSubscriptionPayload {
  mutation: MutationType!
  node: TagLabel
  updatedFields: [String!]
  previousValues: TagLabelPreviousValues
}

input TagLabelSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagLabelWhereInput
  AND: [TagLabelSubscriptionWhereInput!]
  OR: [TagLabelSubscriptionWhereInput!]
  NOT: [TagLabelSubscriptionWhereInput!]
}

input TagLabelUpdateInput {
  name: String
  tags: TagUpdateManyWithoutLabelInput
  order: Int
  category: TagCategoryUpdateOneRequiredWithoutLabelsInput
}

input TagLabelUpdateManyDataInput {
  name: String
  order: Int
}

input TagLabelUpdateManyMutationInput {
  name: String
  order: Int
}

input TagLabelUpdateManyWithoutCategoryInput {
  create: [TagLabelCreateWithoutCategoryInput!]
  delete: [TagLabelWhereUniqueInput!]
  connect: [TagLabelWhereUniqueInput!]
  set: [TagLabelWhereUniqueInput!]
  disconnect: [TagLabelWhereUniqueInput!]
  update: [TagLabelUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [TagLabelUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [TagLabelScalarWhereInput!]
  updateMany: [TagLabelUpdateManyWithWhereNestedInput!]
}

input TagLabelUpdateManyWithWhereNestedInput {
  where: TagLabelScalarWhereInput!
  data: TagLabelUpdateManyDataInput!
}

input TagLabelUpdateOneWithoutTagsInput {
  create: TagLabelCreateWithoutTagsInput
  update: TagLabelUpdateWithoutTagsDataInput
  upsert: TagLabelUpsertWithoutTagsInput
  delete: Boolean
  disconnect: Boolean
  connect: TagLabelWhereUniqueInput
}

input TagLabelUpdateWithoutCategoryDataInput {
  name: String
  tags: TagUpdateManyWithoutLabelInput
  order: Int
}

input TagLabelUpdateWithoutTagsDataInput {
  name: String
  order: Int
  category: TagCategoryUpdateOneRequiredWithoutLabelsInput
}

input TagLabelUpdateWithWhereUniqueWithoutCategoryInput {
  where: TagLabelWhereUniqueInput!
  data: TagLabelUpdateWithoutCategoryDataInput!
}

input TagLabelUpsertWithoutTagsInput {
  update: TagLabelUpdateWithoutTagsDataInput!
  create: TagLabelCreateWithoutTagsInput!
}

input TagLabelUpsertWithWhereUniqueWithoutCategoryInput {
  where: TagLabelWhereUniqueInput!
  update: TagLabelUpdateWithoutCategoryDataInput!
  create: TagLabelCreateWithoutCategoryInput!
}

input TagLabelWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  category: TagCategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagLabelWhereInput!]
  OR: [TagLabelWhereInput!]
  NOT: [TagLabelWhereInput!]
}

input TagLabelWhereUniqueInput {
  id: ID
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TagPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateInput {
  label: TagLabelUpdateOneWithoutTagsInput
  node: ZNodeUpdateOneRequiredWithoutTagsInput
  user: UserUpdateOneRequiredWithoutTagsInput
}

input TagUpdateManyWithoutLabelInput {
  create: [TagCreateWithoutLabelInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutLabelInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutLabelInput!]
  deleteMany: [TagScalarWhereInput!]
}

input TagUpdateManyWithoutNodeInput {
  create: [TagCreateWithoutNodeInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutNodeInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutNodeInput!]
  deleteMany: [TagScalarWhereInput!]
}

input TagUpdateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TagScalarWhereInput!]
}

input TagUpdateWithoutLabelDataInput {
  node: ZNodeUpdateOneRequiredWithoutTagsInput
  user: UserUpdateOneRequiredWithoutTagsInput
}

input TagUpdateWithoutNodeDataInput {
  label: TagLabelUpdateOneWithoutTagsInput
  user: UserUpdateOneRequiredWithoutTagsInput
}

input TagUpdateWithoutUserDataInput {
  label: TagLabelUpdateOneWithoutTagsInput
  node: ZNodeUpdateOneRequiredWithoutTagsInput
}

input TagUpdateWithWhereUniqueWithoutLabelInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutLabelDataInput!
}

input TagUpdateWithWhereUniqueWithoutNodeInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutNodeDataInput!
}

input TagUpdateWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutUserDataInput!
}

input TagUpsertWithWhereUniqueWithoutLabelInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutLabelDataInput!
  create: TagCreateWithoutLabelInput!
}

input TagUpsertWithWhereUniqueWithoutNodeInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutNodeDataInput!
  create: TagCreateWithoutNodeInput!
}

input TagUpsertWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutUserDataInput!
  create: TagCreateWithoutUserInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: TagLabelWhereInput
  node: ZNodeWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  auth0Id: String
  key: String
  admin: Boolean!
  name: String
  email: String
  picture: String
  locale: String
  questions(
    where: QuestionWhereInput
    orderBy: QuestionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Question!]
  answers(
    where: AnswerWhereInput
    orderBy: AnswerOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Answer!]
  flags(
    where: FlagWhereInput
    orderBy: FlagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Flag!]
  tags(
    where: TagWhereInput
    orderBy: TagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Tag!]
  history(
    where: HistoryActionWhereInput
    orderBy: HistoryActionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [HistoryAction!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionCreateManyWithoutUserInput
  answers: AnswerCreateManyWithoutUserInput
  flags: FlagCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
  history: HistoryActionCreateManyWithoutUserInput
}

input UserCreateOneWithoutAnswersInput {
  create: UserCreateWithoutAnswersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFlagsInput {
  create: UserCreateWithoutFlagsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutHistoryInput {
  create: UserCreateWithoutHistoryInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutQuestionsInput {
  create: UserCreateWithoutQuestionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAnswersInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionCreateManyWithoutUserInput
  flags: FlagCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
  history: HistoryActionCreateManyWithoutUserInput
}

input UserCreateWithoutFlagsInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionCreateManyWithoutUserInput
  answers: AnswerCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
  history: HistoryActionCreateManyWithoutUserInput
}

input UserCreateWithoutHistoryInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionCreateManyWithoutUserInput
  answers: AnswerCreateManyWithoutUserInput
  flags: FlagCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
}

input UserCreateWithoutQuestionsInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  answers: AnswerCreateManyWithoutUserInput
  flags: FlagCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
  history: HistoryActionCreateManyWithoutUserInput
}

input UserCreateWithoutTagsInput {
  id: ID
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionCreateManyWithoutUserInput
  answers: AnswerCreateManyWithoutUserInput
  flags: FlagCreateManyWithoutUserInput
  history: HistoryActionCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  auth0Id_ASC
  auth0Id_DESC
  key_ASC
  key_DESC
  admin_ASC
  admin_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  picture_ASC
  picture_DESC
  locale_ASC
  locale_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  auth0Id: String
  key: String
  admin: Boolean!
  name: String
  email: String
  picture: String
  locale: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionUpdateManyWithoutUserInput
  answers: AnswerUpdateManyWithoutUserInput
  flags: FlagUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
  history: HistoryActionUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
}

input UserUpdateOneRequiredWithoutAnswersInput {
  create: UserCreateWithoutAnswersInput
  update: UserUpdateWithoutAnswersDataInput
  upsert: UserUpsertWithoutAnswersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFlagsInput {
  create: UserCreateWithoutFlagsInput
  update: UserUpdateWithoutFlagsDataInput
  upsert: UserUpsertWithoutFlagsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutHistoryInput {
  create: UserCreateWithoutHistoryInput
  update: UserUpdateWithoutHistoryDataInput
  upsert: UserUpsertWithoutHistoryInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutQuestionsInput {
  create: UserCreateWithoutQuestionsInput
  update: UserUpdateWithoutQuestionsDataInput
  upsert: UserUpsertWithoutQuestionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  update: UserUpdateWithoutTagsDataInput
  upsert: UserUpsertWithoutTagsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAnswersDataInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionUpdateManyWithoutUserInput
  flags: FlagUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
  history: HistoryActionUpdateManyWithoutUserInput
}

input UserUpdateWithoutFlagsDataInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionUpdateManyWithoutUserInput
  answers: AnswerUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
  history: HistoryActionUpdateManyWithoutUserInput
}

input UserUpdateWithoutHistoryDataInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionUpdateManyWithoutUserInput
  answers: AnswerUpdateManyWithoutUserInput
  flags: FlagUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
}

input UserUpdateWithoutQuestionsDataInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  answers: AnswerUpdateManyWithoutUserInput
  flags: FlagUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
  history: HistoryActionUpdateManyWithoutUserInput
}

input UserUpdateWithoutTagsDataInput {
  auth0Id: String
  key: String
  admin: Boolean
  name: String
  email: String
  picture: String
  locale: String
  questions: QuestionUpdateManyWithoutUserInput
  answers: AnswerUpdateManyWithoutUserInput
  flags: FlagUpdateManyWithoutUserInput
  history: HistoryActionUpdateManyWithoutUserInput
}

input UserUpsertWithoutAnswersInput {
  update: UserUpdateWithoutAnswersDataInput!
  create: UserCreateWithoutAnswersInput!
}

input UserUpsertWithoutFlagsInput {
  update: UserUpdateWithoutFlagsDataInput!
  create: UserCreateWithoutFlagsInput!
}

input UserUpsertWithoutHistoryInput {
  update: UserUpdateWithoutHistoryDataInput!
  create: UserCreateWithoutHistoryInput!
}

input UserUpsertWithoutQuestionsInput {
  update: UserUpdateWithoutQuestionsDataInput!
  create: UserCreateWithoutQuestionsInput!
}

input UserUpsertWithoutTagsInput {
  update: UserUpdateWithoutTagsDataInput!
  create: UserCreateWithoutTagsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  auth0Id: String
  auth0Id_not: String
  auth0Id_in: [String!]
  auth0Id_not_in: [String!]
  auth0Id_lt: String
  auth0Id_lte: String
  auth0Id_gt: String
  auth0Id_gte: String
  auth0Id_contains: String
  auth0Id_not_contains: String
  auth0Id_starts_with: String
  auth0Id_not_starts_with: String
  auth0Id_ends_with: String
  auth0Id_not_ends_with: String
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  admin: Boolean
  admin_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  picture: String
  picture_not: String
  picture_in: [String!]
  picture_not_in: [String!]
  picture_lt: String
  picture_lte: String
  picture_gt: String
  picture_gte: String
  picture_contains: String
  picture_not_contains: String
  picture_starts_with: String
  picture_not_starts_with: String
  picture_ends_with: String
  picture_not_ends_with: String
  locale: String
  locale_not: String
  locale_in: [String!]
  locale_not_in: [String!]
  locale_lt: String
  locale_lte: String
  locale_gt: String
  locale_gte: String
  locale_contains: String
  locale_not_contains: String
  locale_starts_with: String
  locale_not_starts_with: String
  locale_ends_with: String
  locale_not_ends_with: String
  questions_every: QuestionWhereInput
  questions_some: QuestionWhereInput
  questions_none: QuestionWhereInput
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  flags_every: FlagWhereInput
  flags_some: FlagWhereInput
  flags_none: FlagWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  history_every: HistoryActionWhereInput
  history_some: HistoryActionWhereInput
  history_none: HistoryActionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  auth0Id: String
}

type ZNode {
  id: ID!
  question: Question
  answer: Answer
  flags(
    where: FlagWhereInput
    orderBy: FlagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Flag!]
  tags(
    where: TagWhereInput
    orderBy: TagOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [Tag!]
  history(
    where: HistoryActionWhereInput
    orderBy: HistoryActionOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [HistoryAction!]
  highlights: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ZNodeConnection {
  pageInfo: PageInfo!
  edges: [ZNodeEdge]!
  aggregate: AggregateZNode!
}

input ZNodeCreateInput {
  id: ID
  question: QuestionCreateOneWithoutNodeInput
  answer: AnswerCreateOneWithoutNodeInput
  flags: FlagCreateManyWithoutNodeInput
  tags: TagCreateManyWithoutNodeInput
  history: HistoryActionCreateManyWithoutNodeInput
  highlights: Json
}

input ZNodeCreateOneWithoutAnswerInput {
  create: ZNodeCreateWithoutAnswerInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeCreateOneWithoutFlagsInput {
  create: ZNodeCreateWithoutFlagsInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeCreateOneWithoutHistoryInput {
  create: ZNodeCreateWithoutHistoryInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeCreateOneWithoutQuestionInput {
  create: ZNodeCreateWithoutQuestionInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeCreateOneWithoutTagsInput {
  create: ZNodeCreateWithoutTagsInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeCreateWithoutAnswerInput {
  id: ID
  question: QuestionCreateOneWithoutNodeInput
  flags: FlagCreateManyWithoutNodeInput
  tags: TagCreateManyWithoutNodeInput
  history: HistoryActionCreateManyWithoutNodeInput
  highlights: Json
}

input ZNodeCreateWithoutFlagsInput {
  id: ID
  question: QuestionCreateOneWithoutNodeInput
  answer: AnswerCreateOneWithoutNodeInput
  tags: TagCreateManyWithoutNodeInput
  history: HistoryActionCreateManyWithoutNodeInput
  highlights: Json
}

input ZNodeCreateWithoutHistoryInput {
  id: ID
  question: QuestionCreateOneWithoutNodeInput
  answer: AnswerCreateOneWithoutNodeInput
  flags: FlagCreateManyWithoutNodeInput
  tags: TagCreateManyWithoutNodeInput
  highlights: Json
}

input ZNodeCreateWithoutQuestionInput {
  id: ID
  answer: AnswerCreateOneWithoutNodeInput
  flags: FlagCreateManyWithoutNodeInput
  tags: TagCreateManyWithoutNodeInput
  history: HistoryActionCreateManyWithoutNodeInput
  highlights: Json
}

input ZNodeCreateWithoutTagsInput {
  id: ID
  question: QuestionCreateOneWithoutNodeInput
  answer: AnswerCreateOneWithoutNodeInput
  flags: FlagCreateManyWithoutNodeInput
  history: HistoryActionCreateManyWithoutNodeInput
  highlights: Json
}

type ZNodeEdge {
  node: ZNode!
  cursor: String!
}

enum ZNodeOrderByInput {
  id_ASC
  id_DESC
  highlights_ASC
  highlights_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ZNodePreviousValues {
  id: ID!
  highlights: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ZNodeSubscriptionPayload {
  mutation: MutationType!
  node: ZNode
  updatedFields: [String!]
  previousValues: ZNodePreviousValues
}

input ZNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ZNodeWhereInput
  AND: [ZNodeSubscriptionWhereInput!]
  OR: [ZNodeSubscriptionWhereInput!]
  NOT: [ZNodeSubscriptionWhereInput!]
}

input ZNodeUpdateInput {
  question: QuestionUpdateOneWithoutNodeInput
  answer: AnswerUpdateOneWithoutNodeInput
  flags: FlagUpdateManyWithoutNodeInput
  tags: TagUpdateManyWithoutNodeInput
  history: HistoryActionUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpdateManyMutationInput {
  highlights: Json
}

input ZNodeUpdateOneRequiredWithoutAnswerInput {
  create: ZNodeCreateWithoutAnswerInput
  update: ZNodeUpdateWithoutAnswerDataInput
  upsert: ZNodeUpsertWithoutAnswerInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeUpdateOneRequiredWithoutFlagsInput {
  create: ZNodeCreateWithoutFlagsInput
  update: ZNodeUpdateWithoutFlagsDataInput
  upsert: ZNodeUpsertWithoutFlagsInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeUpdateOneRequiredWithoutHistoryInput {
  create: ZNodeCreateWithoutHistoryInput
  update: ZNodeUpdateWithoutHistoryDataInput
  upsert: ZNodeUpsertWithoutHistoryInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeUpdateOneRequiredWithoutQuestionInput {
  create: ZNodeCreateWithoutQuestionInput
  update: ZNodeUpdateWithoutQuestionDataInput
  upsert: ZNodeUpsertWithoutQuestionInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeUpdateOneRequiredWithoutTagsInput {
  create: ZNodeCreateWithoutTagsInput
  update: ZNodeUpdateWithoutTagsDataInput
  upsert: ZNodeUpsertWithoutTagsInput
  connect: ZNodeWhereUniqueInput
}

input ZNodeUpdateWithoutAnswerDataInput {
  question: QuestionUpdateOneWithoutNodeInput
  flags: FlagUpdateManyWithoutNodeInput
  tags: TagUpdateManyWithoutNodeInput
  history: HistoryActionUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpdateWithoutFlagsDataInput {
  question: QuestionUpdateOneWithoutNodeInput
  answer: AnswerUpdateOneWithoutNodeInput
  tags: TagUpdateManyWithoutNodeInput
  history: HistoryActionUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpdateWithoutHistoryDataInput {
  question: QuestionUpdateOneWithoutNodeInput
  answer: AnswerUpdateOneWithoutNodeInput
  flags: FlagUpdateManyWithoutNodeInput
  tags: TagUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpdateWithoutQuestionDataInput {
  answer: AnswerUpdateOneWithoutNodeInput
  flags: FlagUpdateManyWithoutNodeInput
  tags: TagUpdateManyWithoutNodeInput
  history: HistoryActionUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpdateWithoutTagsDataInput {
  question: QuestionUpdateOneWithoutNodeInput
  answer: AnswerUpdateOneWithoutNodeInput
  flags: FlagUpdateManyWithoutNodeInput
  history: HistoryActionUpdateManyWithoutNodeInput
  highlights: Json
}

input ZNodeUpsertWithoutAnswerInput {
  update: ZNodeUpdateWithoutAnswerDataInput!
  create: ZNodeCreateWithoutAnswerInput!
}

input ZNodeUpsertWithoutFlagsInput {
  update: ZNodeUpdateWithoutFlagsDataInput!
  create: ZNodeCreateWithoutFlagsInput!
}

input ZNodeUpsertWithoutHistoryInput {
  update: ZNodeUpdateWithoutHistoryDataInput!
  create: ZNodeCreateWithoutHistoryInput!
}

input ZNodeUpsertWithoutQuestionInput {
  update: ZNodeUpdateWithoutQuestionDataInput!
  create: ZNodeCreateWithoutQuestionInput!
}

input ZNodeUpsertWithoutTagsInput {
  update: ZNodeUpdateWithoutTagsDataInput!
  create: ZNodeCreateWithoutTagsInput!
}

input ZNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  question: QuestionWhereInput
  answer: AnswerWhereInput
  flags_every: FlagWhereInput
  flags_some: FlagWhereInput
  flags_none: FlagWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  history_every: HistoryActionWhereInput
  history_some: HistoryActionWhereInput
  history_none: HistoryActionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ZNodeWhereInput!]
  OR: [ZNodeWhereInput!]
  NOT: [ZNodeWhereInput!]
}

input ZNodeWhereUniqueInput {
  id: ID
}
